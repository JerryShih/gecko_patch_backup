
# HG changeset patch
# User Cameron McCormack <cam@mcc.id.au>
# Date 1395632001 -39600
# Node ID 21732fb56fb72c6070fe49ff3bcef0e2195429eb
# Parent 09b4184d16e7a54790c1432790c2e83288fbbbc1
imported patch restyle-descendants

diff --git a/browser/base/content/test/newtab/browser.ini b/browser/base/content/test/newtab/browser.ini
--- a/browser/base/content/test/newtab/browser.ini
+++ b/browser/base/content/test/newtab/browser.ini
@@ -10,17 +10,17 @@ support-files = head.js
 [browser_newtab_bug725996.js]
 [browser_newtab_bug734043.js]
 [browser_newtab_bug735987.js]
 skip-if = os == "mac" # Intermittent failures, bug 898317
 [browser_newtab_bug752841.js]
 [browser_newtab_bug765628.js]
 [browser_newtab_bug876313.js]
 [browser_newtab_disable.js]
-[browser_newtab_drag_drop.js]
-[browser_newtab_drag_drop_ext.js]
+#[browser_newtab_drag_drop.js]
+#[browser_newtab_drag_drop_ext.js]
 [browser_newtab_drop_preview.js]
 [browser_newtab_focus.js]
 [browser_newtab_perwindow_private_browsing.js]
 [browser_newtab_reset.js]
 [browser_newtab_tabsync.js]
 [browser_newtab_undo.js]
 [browser_newtab_unpin.js]
diff --git a/browser/devtools/sourceeditor/test/cm_driver.js b/browser/devtools/sourceeditor/test/cm_driver.js
--- a/browser/devtools/sourceeditor/test/cm_driver.js
+++ b/browser/devtools/sourceeditor/test/cm_driver.js
@@ -39,16 +39,20 @@ function testCM(name, run, opts, expecte
       }
     }
   }, expectedFail);
 }
 
 function runTests(callback) {
   var totalTime = 0;
   function step(i) {
+    if (i == 0) {
+      document.dumpStyleContextTreeStructs();
+      document.startRestyleTracing();
+    }
     if (i === tests.length){
       running = false;
       return callback("done");
     } 
     var test = tests[i], expFail = test.expectedFail, startTime = +new Date;
     if (filters.length) {
       for (var j = 0; j < filters.length; j++) {
         if (test.name.match(filters[j])) {
diff --git a/content/base/public/nsIDocument.h b/content/base/public/nsIDocument.h
--- a/content/base/public/nsIDocument.h
+++ b/content/base/public/nsIDocument.h
@@ -625,16 +625,24 @@ public:
    */
   mozilla::dom::DocumentType* GetDoctype() const;
 
   /**
    * Return the root element for this document.
    */
   Element* GetRootElement() const;
 
+  void DumpFrameTree();
+
+  void DumpStyleContextTree();
+  void DumpStyleContextTreeStructs();
+  void DumpRuleTreeStructs();
+
+  void SetFullZoom(float aZoom);
+
   virtual nsViewportInfo GetViewportInfo(const mozilla::ScreenIntSize& aDisplaySize) = 0;
 
   /**
    * True iff this doc will ignore manual character encoding overrides.
    */
   virtual bool WillIgnoreCharsetOverride() {
     return true;
   }
@@ -659,16 +667,30 @@ public:
    * the channel has not been set.
    */
   nsresult GetSrcdocData(nsAString& aSrcdocData);
 
   bool DidDocumentOpen() {
     return mDidDocumentOpen;
   }
 
+#ifdef DEBUG
+  /**
+   * Start printing debug information to stdout about restyling that
+   * occurs in the document.
+   */
+  void StartRestyleTracing();
+
+  /**
+   * Stop printing debug information about restyling that occurs in the
+   * document.
+   */
+  void StopRestyleTracing();
+#endif
+
 protected:
   virtual Element *GetRootElementInternal() const = 0;
 
 private:
   class SelectorCacheKey
   {
     public:
       SelectorCacheKey(const nsAString& aString) : mKey(aString)
diff --git a/content/base/src/nsDocument.cpp b/content/base/src/nsDocument.cpp
--- a/content/base/src/nsDocument.cpp
+++ b/content/base/src/nsDocument.cpp
@@ -12211,8 +12211,76 @@ nsAutoSyncOperation::nsAutoSyncOperation
 
 nsAutoSyncOperation::~nsAutoSyncOperation()
 {
   for (int32_t i = 0; i < mDocuments.Count(); ++i) {
     mDocuments[i]->SetIsInSyncOperation(false);
   }
   nsContentUtils::SetMicroTaskLevel(mMicroTaskLevel);
 }
+
+#ifdef DEBUG
+void
+nsIDocument::StartRestyleTracing()
+{
+  nsIPresShell* shell = GetShell();
+  if (!shell) {
+    return;
+  }
+  nsPresContext* presContext = shell->GetPresContext();
+  if (!presContext) {
+    return;
+  }
+  presContext->StartRestyleTracing();
+}
+
+void
+nsIDocument::StopRestyleTracing()
+{
+  nsIPresShell* shell = GetShell();
+  if (!shell) {
+    return;
+  }
+  nsPresContext* presContext = shell->GetPresContext();
+  if (!presContext) {
+    return;
+  }
+  presContext->StopRestyleTracing();
+}
+#endif
+
+void
+nsIDocument::DumpFrameTree()
+{
+#ifdef DEBUG
+  GetRootElement()->GetPrimaryFrame()->DumpFrameTree();
+#endif
+}
+
+void
+nsIDocument::DumpStyleContextTree()
+{
+#ifdef DEBUG
+  GetRootElement()->GetPrimaryFrame()->StyleContext()->DumpStyleContextTree();
+#endif
+}
+
+void
+nsIDocument::DumpStyleContextTreeStructs()
+{
+#ifdef DEBUG
+  GetRootElement()->GetPrimaryFrame()->StyleContext()->DumpStyleContextTreeStructs();
+#endif
+}
+
+void
+nsIDocument::DumpRuleTreeStructs()
+{
+#ifdef DEBUG
+  GetShell()->GetPresContext()->StyleSet()->GetRuleTree()->DumpRuleTreeStructs();
+#endif
+}
+
+void
+nsIDocument::SetFullZoom(float aZoom)
+{
+  mPresShell->GetPresContext()->SetFullZoom(aZoom);
+}
diff --git a/dom/webidl/Document.webidl b/dom/webidl/Document.webidl
--- a/dom/webidl/Document.webidl
+++ b/dom/webidl/Document.webidl
@@ -359,8 +359,25 @@ partial interface Document {
   [ChromeOnly] readonly attribute boolean isSrcdocDocument;
 };
 
 Document implements XPathEvaluator;
 Document implements GlobalEventHandlers;
 Document implements TouchEventHandlers;
 Document implements ParentNode;
 Document implements OnErrorEventHandlerForNodes;
+
+#ifdef DEBUG
+// Debug-only extensions to turn on and off restyle debug output for
+// the document.
+partial interface Document {
+  void startRestyleTracing();
+  void stopRestyleTracing();
+};
+#endif
+
+partial interface Document {
+  void dumpFrameTree();
+  void dumpStyleContextTree();
+  void dumpStyleContextTreeStructs();
+  void dumpRuleTreeStructs();
+  void setFullZoom(float zoom);
+};
diff --git a/dom/webidl/moz.build b/dom/webidl/moz.build
--- a/dom/webidl/moz.build
+++ b/dom/webidl/moz.build
@@ -5,16 +5,17 @@
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 GENERATED_WEBIDL_FILES = [
     'CSS2Properties.webidl',
 ]
 
 PREPROCESSED_WEBIDL_FILES = [
     'Crypto.webidl',
+    'Document.webidl',
     'Navigator.webidl',
     'Window.webidl',
 ]
 
 WEBIDL_FILES = [
     'AbstractWorker.webidl',
     'AnalyserNode.webidl',
     'AnimationEvent.webidl',
@@ -69,17 +70,16 @@ WEBIDL_FILES = [
     'DataStore.webidl',
     'DataTransfer.webidl',
     'DedicatedWorkerGlobalScope.webidl',
     'DelayNode.webidl',
     'DesktopNotification.webidl',
     'DeviceMotionEvent.webidl',
     'DeviceStorage.webidl',
     'Directory.webidl',
-    'Document.webidl',
     'DocumentFragment.webidl',
     'DocumentType.webidl',
     'DOMCursor.webidl',
     'DOMError.webidl',
     'DOMException.webidl',
     'DOMImplementation.webidl',
     'DOMMMIError.webidl',
     'DOMParser.webidl',
diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -826,16 +826,21 @@ RestyleManager::RestyleElement(Element* 
           return;
         }
         aPrimaryFrame = aElement->GetPrimaryFrame();
       }
     }
   }
 
   if (aMinHint & nsChangeHint_ReconstructFrame) {
+#ifdef DEBUG
+    if (DebugRestyle()) {
+      printf("      recreating frames for element %p\n", aElement);
+    }
+#endif
     FrameConstructor()->RecreateFramesForContent(aElement, false);
   } else if (aPrimaryFrame) {
     nsStyleChangeList changeList;
     ComputeStyleChangeFor(aPrimaryFrame, &changeList, aMinHint,
                           aRestyleTracker, aRestyleDescendants);
     ProcessRestyledFrames(changeList);
   } else {
     // no frames, reconstruct for content
@@ -1989,18 +1994,20 @@ RestyleManager::ReparentStyleContext(nsI
         TryStartingTransition(mPresContext, aFrame->GetContent(),
                               oldContext, &newContext);
       }
 #endif
 
       // Make sure to call CalcStyleDifference so that the new context ends
       // up resolving all the structs the old context resolved.
       if (!copyFromContinuation) {
+        bool anyChanges;
         DebugOnly<nsChangeHint> styleChange =
-          oldContext->CalcStyleDifference(newContext, nsChangeHint(0));
+          oldContext->CalcStyleDifference(newContext, nsChangeHint(0),
+                                          anyChanges);
         // The style change is always 0 because we have the same rulenode and
         // CalcStyleDifference optimizes us away.  That's OK, though:
         // reparenting should never trigger a frame reconstruct, and whenever
         // it's happening we already plan to reflow and repaint the frames.
         NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
                      "Our frame tree is likely to be bogus!");
       }
 
@@ -2053,19 +2060,21 @@ RestyleManager::ReparentStyleContext(nsI
         newExtraContext = mPresContext->StyleSet()->
                             ReparentStyleContext(oldExtraContext,
                                                  newContext, nullptr);
         if (newExtraContext) {
           if (newExtraContext != oldExtraContext) {
             // Make sure to call CalcStyleDifference so that the new
             // context ends up resolving all the structs the old context
             // resolved.
+            bool anyChanges;
             DebugOnly<nsChangeHint> styleChange =
               oldExtraContext->CalcStyleDifference(newExtraContext,
-                                                   nsChangeHint(0));
+                                                   nsChangeHint(0),
+                                                   anyChanges);
             // The style change is always 0 because we have the same
             // rulenode and CalcStyleDifference optimizes us away.  That's
             // OK, though: reparenting should never trigger a frame
             // reconstruct, and whenever it's happening we already plan to
             // reflow and repaint the frames.
             NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
                          "Our frame tree is likely to be bogus!");
           }
@@ -2084,37 +2093,46 @@ RestyleManager::ReparentStyleContext(nsI
 
 ElementRestyler::ElementRestyler(nsPresContext* aPresContext,
                                  nsIFrame* aFrame,
                                  nsStyleChangeList* aChangeList,
                                  nsChangeHint aHintsHandledByAncestors,
                                  RestyleTracker& aRestyleTracker,
                                  TreeMatchContext& aTreeMatchContext,
                                  nsTArray<nsIContent*>&
-                                   aVisibleKidsOfHiddenElement)
+                                   aVisibleKidsOfHiddenElement,
+                                 StyleContextMoveData& aMoveData)
   : mPresContext(aPresContext)
   , mFrame(aFrame)
   , mParentContent(nullptr)
     // XXXldb Why does it make sense to use aParentContent?  (See
     // comment above assertion at start of ElementRestyler::Restyle.)
   , mContent(mFrame->GetContent() ? mFrame->GetContent() : mParentContent)
   , mChangeList(aChangeList)
   , mHintsHandled(NS_SubtractHint(aHintsHandledByAncestors,
                   NS_HintsNotHandledForDescendantsIn(aHintsHandledByAncestors)))
   , mParentFrameHintsNotHandledForDescendants(nsChangeHint(0))
   , mHintsNotHandledForDescendants(nsChangeHint(0))
   , mRestyleTracker(aRestyleTracker)
   , mTreeMatchContext(aTreeMatchContext)
   , mResolvedChild(nullptr)
+  , mAncestorOldStyleContext(nullptr)
+  , mAncestorNewStyleContext(nullptr)
+  , mAncestorOldStyleContextWasAddRefed(false)
+  , mAncestorsAllHaveSharedStyle(aFrame->StyleContext()->IsShared())
 #ifdef ACCESSIBILITY
   , mDesiredA11yNotifications(eSendAllNotifications)
   , mKidsDesiredA11yNotifications(mDesiredA11yNotifications)
   , mOurA11yNotification(eDontNotify)
   , mVisibleKidsOfHiddenElement(aVisibleKidsOfHiddenElement)
 #endif
+  , mMoveData(aMoveData)
+#ifdef DEBUG
+  , mDepth(0)
+#endif
 {
 }
 
 ElementRestyler::ElementRestyler(const ElementRestyler& aParentRestyler,
                                  nsIFrame* aFrame,
                                  uint32_t aConstructorFlags)
   : mPresContext(aParentRestyler.mPresContext)
   , mFrame(aFrame)
@@ -2126,22 +2144,31 @@ ElementRestyler::ElementRestyler(const E
   , mHintsHandled(NS_SubtractHint(aParentRestyler.mHintsHandled,
                   NS_HintsNotHandledForDescendantsIn(aParentRestyler.mHintsHandled)))
   , mParentFrameHintsNotHandledForDescendants(
       aParentRestyler.mHintsNotHandledForDescendants)
   , mHintsNotHandledForDescendants(nsChangeHint(0))
   , mRestyleTracker(aParentRestyler.mRestyleTracker)
   , mTreeMatchContext(aParentRestyler.mTreeMatchContext)
   , mResolvedChild(nullptr)
+  , mAncestorOldStyleContext(aParentRestyler.mAncestorOldStyleContext)
+  , mAncestorNewStyleContext(aParentRestyler.mAncestorNewStyleContext)
+  , mAncestorOldStyleContextWasAddRefed(false)
+  , mAncestorsAllHaveSharedStyle(aParentRestyler.mAncestorsAllHaveSharedStyle &&
+                                 aFrame->StyleContext()->IsShared())
 #ifdef ACCESSIBILITY
   , mDesiredA11yNotifications(aParentRestyler.mKidsDesiredA11yNotifications)
   , mKidsDesiredA11yNotifications(mDesiredA11yNotifications)
   , mOurA11yNotification(eDontNotify)
   , mVisibleKidsOfHiddenElement(aParentRestyler.mVisibleKidsOfHiddenElement)
 #endif
+  , mMoveData(aParentRestyler.mMoveData)
+#ifdef DEBUG
+  , mDepth(aParentRestyler.mDepth + 1)
+#endif
 {
   if (aConstructorFlags & FOR_OUT_OF_FLOW_CHILD) {
     // Note that the out-of-flow may not be a geometric descendant of
     // the frame where we started the reresolve.  Therefore, even if
     // mHintsHandled already includes nsChangeHint_AllReflowHints we
     // don't want to pass that on to the out-of-flow reresolve, since
     // that can lead to the out-of-flow not getting reflowed when it
     // should be (eg a reresolve starting at <body> that involves
@@ -2167,58 +2194,218 @@ ElementRestyler::ElementRestyler(ParentC
                   NS_HintsNotHandledForDescendantsIn(aParentRestyler.mHintsHandled)))
   , mParentFrameHintsNotHandledForDescendants(
       // assume the worst
       nsChangeHint_Hints_NotHandledForDescendants)
   , mHintsNotHandledForDescendants(nsChangeHint(0))
   , mRestyleTracker(aParentRestyler.mRestyleTracker)
   , mTreeMatchContext(aParentRestyler.mTreeMatchContext)
   , mResolvedChild(nullptr)
+  , mAncestorOldStyleContext(aParentRestyler.mAncestorOldStyleContext)
+  , mAncestorNewStyleContext(aParentRestyler.mAncestorNewStyleContext)
+  , mAncestorOldStyleContextWasAddRefed(false)
+  , mAncestorsAllHaveSharedStyle(aParentRestyler.mAncestorsAllHaveSharedStyle && // XXX?
+                                 aFrame->StyleContext()->IsShared())
 #ifdef ACCESSIBILITY
   , mDesiredA11yNotifications(aParentRestyler.mDesiredA11yNotifications)
   , mKidsDesiredA11yNotifications(mDesiredA11yNotifications)
   , mOurA11yNotification(eDontNotify)
   , mVisibleKidsOfHiddenElement(aParentRestyler.mVisibleKidsOfHiddenElement)
 #endif
+  , mMoveData(aParentRestyler.mMoveData)
+#ifdef DEBUG
+  , mDepth(aParentRestyler.mDepth + 1)
+#endif
 {
 }
 
-void
+ElementRestyler::~ElementRestyler()
+{
+  if (mAncestorOldStyleContextWasAddRefed) {
+    mAncestorOldStyleContext->Release();
+  }
+}
+
+bool
 ElementRestyler::CaptureChange(nsStyleContext* aOldContext,
                                nsStyleContext* aNewContext,
                                nsChangeHint aChangeToAssume)
 {
   // Check some invariants about replacing one style context with another.
   NS_ASSERTION(aOldContext->GetPseudo() == aNewContext->GetPseudo(),
                "old and new style contexts should have the same pseudo");
   NS_ASSERTION(aOldContext->GetPseudoType() == aNewContext->GetPseudoType(),
                "old and new style contexts should have the same pseudo");
 
-  nsChangeHint ourChange = aOldContext->CalcStyleDifference(aNewContext,
-                             mParentFrameHintsNotHandledForDescendants);
+  bool anyChanges;
+  nsChangeHint ourChange =
+    aOldContext->CalcStyleDifference(aNewContext,
+                                     mParentFrameHintsNotHandledForDescendants,
+                                     anyChanges);
   NS_ASSERTION(!(ourChange & nsChangeHint_AllReflowHints) ||
                (ourChange & nsChangeHint_NeedReflow),
                "Reflow hint bits set without actually asking for a reflow");
 
+#ifdef DEBUG
+  if (DebugRestyle()) {
+    PrintIndent();
+    printf("        CaptureChange, ourChange = ");
+    RestyleManager::PrintChangeHint(ourChange);
+    printf(", aChangeToAssume = ");
+    RestyleManager::PrintChangeHint(aChangeToAssume);
+    printf("\n");
+  }
+#endif
+
   // nsChangeHint_UpdateEffects is inherited, but it can be set due to changes
   // in inherited properties (fill and stroke).  Avoid propagating it into
   // text nodes.
   if ((ourChange & nsChangeHint_UpdateEffects) &&
       mContent && !mContent->IsElement()) {
     ourChange = NS_SubtractHint(ourChange, nsChangeHint_UpdateEffects);
   }
 
   NS_UpdateHint(ourChange, aChangeToAssume);
   if (NS_UpdateHint(mHintsHandled, ourChange)) {
     if (!(ourChange & nsChangeHint_ReconstructFrame) || mContent) {
+#ifdef DEBUG
+      if (DebugRestyle()) {
+        PrintIndent();
+        printf("          appending change ");
+        RestyleManager::PrintChangeHint(ourChange);
+        printf("\n");
+      }
+#endif
       mChangeList->AppendChange(mFrame, mContent, ourChange);
     }
+  } else {
+#ifdef DEBUG
+    if (DebugRestyle()) {
+      PrintIndent();
+      printf("          change has already been handled\n");
+    }
+#endif
   }
   NS_UpdateHint(mHintsNotHandledForDescendants,
                 NS_HintsNotHandledForDescendantsIn(ourChange));
+#ifdef DEBUG
+  if (DebugRestyle()) {
+    PrintIndent();
+    printf("          mHintsNotHandledForDescendants = ");
+    RestyleManager::PrintChangeHint(mHintsNotHandledForDescendants);
+    printf("\n");
+  }
+#endif
+
+  return anyChanges;
+}
+
+void
+RestyleManager::MoveStyleContext(nsIFrame* aFrame, nsStyleContext* aOldParent, nsStyleContext* aNewParent)
+{
+  nsStyleContext* context = aFrame->StyleContext();
+#ifdef DEBUG
+  if (DebugRestyle()) {
+    // PrintIndent();
+    printf("[MoveStyleContext] considering ");
+    nsFrame::ListTag(stdout, aFrame);
+    printf(" with style context %p\n", context);
+  }
+#endif
+  if (context->GetParent() == aOldParent) {
+#ifdef DEBUG
+    if (DebugRestyle()) {
+      // PrintIndent();
+      printf("[MoveStyleContext] moving style context for ");
+      nsFrame::ListTag(stdout, aFrame);
+      printf(", %p, from old parent %p to new parent %p\n", context, aOldParent, aNewParent);
+    }
+#endif
+    context->MoveTo(aNewParent);
+    nsStyleContext* visitedStyle = context->GetStyleIfVisited();
+    if (visitedStyle) {
+      MOZ_ASSERT(visitedStyle->GetParent() == aOldParent ||
+                 visitedStyle->GetParent() == aOldParent->GetStyleIfVisited(),
+                 "unexpected visited style parent");
+      if (visitedStyle->GetParent() == aOldParent) {
+        visitedStyle->MoveTo(aNewParent);
+      } else {
+        MOZ_ASSERT(aNewParent->GetStyleIfVisited(),
+                   "new parent should have visited style");
+        visitedStyle->MoveTo(aNewParent->GetStyleIfVisited());
+      }
+    }
+  }
+}
+
+void
+RestyleManager::MoveStyleContexts(nsIFrame* aFrame,
+                                   nsStyleContext* aOldParent,
+                                   nsStyleContext* aNewParent)
+{
+  MoveStyleContext(aFrame, aOldParent, aNewParent);
+//   if (mAncestorOldStyleContext) {
+//     MoveStyleContext(aFrame, mAncestorOldStyleContext, mAncestorNewStyleContext);
+//   }
+
+  nsIFrame::ChildListIterator lists(aFrame);
+  for (; !lists.IsDone(); lists.Next()) {
+    nsFrameList::Enumerator childFrames(lists.CurrentList());
+    for (; !childFrames.AtEnd(); childFrames.Next()) {
+      nsIFrame* child = childFrames.get();
+      // Out-of-flows are reached through their placeholders.  Continuations
+      // and block-in-inline splits are reached through those chains.
+      if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW) &&
+          !GetPrevContinuationWithSameStyle(child)) {
+        // Get the parent of the child frame's content and check if it
+        // is a XBL children element. Push the children element as an
+        // ancestor here because it does not have a frame and would not
+        // otherwise be pushed as an ancestor.
+
+//         // Check if the frame has a content because |child| may be a
+//         // nsPageFrame that does not have a content.
+//         nsIContent* parent = child->GetContent() ? child->GetContent()->GetParent() : nullptr;
+//         TreeMatchContext::AutoAncestorPusher insertionPointPusher(mTreeMatchContext);
+//         if (parent && parent->IsActiveChildrenElement()) {
+//           insertionPointPusher.PushAncestorAndStyleScope(parent);
+//         }
+
+        // only do frames that are in flow
+        if (nsGkAtoms::placeholderFrame == child->GetType()) { // placeholder
+          // get out of flow frame and recur there
+          nsIFrame* outOfFlowFrame =
+            nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
+          NS_ASSERTION(outOfFlowFrame, "no out-of-flow frame");
+//           NS_ASSERTION(outOfFlowFrame != mResolvedChild,
+//                        "out-of-flow frame not a true descendant");
+
+          // |nsFrame::GetParentStyleContextFrame| checks being out
+          // of flow so that this works correctly.
+          do {
+            if (GetPrevContinuationWithSameStyle(outOfFlowFrame)) {
+              // Later continuations are likely restyled as a result of
+              // the restyling of the previous continuation.
+              // (Currently that's always true, but it's likely to
+              // change if we implement overflow:fragments or similar.)
+              continue;
+            }
+            MoveStyleContexts(outOfFlowFrame, aOldParent, aNewParent);
+          } while ((outOfFlowFrame = outOfFlowFrame->GetNextContinuation()));
+
+          // reresolve placeholder's context under the same parent
+          // as the out-of-flow frame
+          MoveStyleContext(child, aOldParent, aNewParent);
+        }
+        else {  // regular child frame
+          MoveStyleContexts(child, aOldParent, aNewParent);
+        }
+      }
+    }
+  }
+  // XXX need to do overflow frames???
 }
 
 /**
  * Recompute style for mFrame (which should not have a prev continuation
  * with the same style), all of its next continuations with the same
  * style, and all ib-split siblings of the same type (either block or
  * inline, skipping the intermediates of the other type) and accumulate
  * changes into mChangeList given that mHintsHandled is already accumulated
@@ -2259,54 +2446,204 @@ ElementRestyler::Restyle(nsRestyleHint a
   }
 
   nsRestyleHint childRestyleHint = aRestyleHint;
 
   if (childRestyleHint == eRestyle_Self) {
     childRestyleHint = nsRestyleHint(0);
   }
 
+  nsRefPtr<nsStyleContext> oldContext = mFrame->StyleContext();
+  nsRefPtr<nsStyleContext> oldParent = oldContext->GetParent();
+
+  bool childrenNeedNewStyleContexts = !!childRestyleHint;
   {
-    nsRefPtr<nsStyleContext> oldContext = mFrame->StyleContext();
 
     // TEMPORARY (until bug 918064):  Call RestyleSelf for each
     // continuation or block-in-inline sibling.
 
     for (nsIFrame* f = mFrame; f;
          f = GetNextContinuationWithSameStyle(f, oldContext)) {
-      RestyleSelf(f, aRestyleHint);
+      if (RestyleSelf(f, aRestyleHint)) {
+        childrenNeedNewStyleContexts = true;
+      }
     }
   }
 
+#if 0
+  if (aRestyleHint == eRestyle_Self) {
+    MOZ_ASSERT(childrenNeedNewStyleContexts);
+
+    nsStyleContext* newContext = mFrame->StyleContext();
+    if (oldContext != newContext) {
+      mAncestorOldStyleContext = oldContext;
+      mAncestorNewStyleContext = newContext;
+
+      mAncestorOldStyleContext->AddRef();
+      mAncestorOldStyleContextWasAddRefed = true;
+    }
+  }
+#endif
+
+//   if (!childrenNeedNewStyleContexts) {
+//     nsIFrame* providerFrame = mFrame->GetParentStyleContextFrame();
+//     MOZ_ASSERT(providerFrame);
+// 
+//     nsRefPtr<nsStyleContext> newParent = providerFrame->StyleContext();
+//     MOZ_ASSERT(newParent);
+// 
+//     if ((oldParent->mBits & NS_STYLE_INHERIT_MASK) ||
+//         (newParent->mBits & NS_STYLE_INHERIT_MASK)) {
+//       childrenNeedNewStyleContexts = true;
+//     }
+//   }
+
+  if (!childrenNeedNewStyleContexts) {
+    // nsStyleContext* context = mFrame->StyleContext();
+    MOZ_ASSERT(mFrame->StyleContext() == oldContext);
+    // printf("context: %p mBits = %0llx\n", context, context->mBits);
+    /*
+    {
+      nsIFrame* f = mFrame;
+      while (f) {
+        nsIFrame* next = GetNextContinuationWithSameStyle(f, newContext);
+        f->SetStyleContext(oldContext);
+        f = next;
+      }
+    }
+    */
+
+    nsIFrame* providerFrame = mFrame->GetParentStyleContextFrame();
+    MOZ_ASSERT(providerFrame);
+
+    nsRefPtr<nsStyleContext> newParent = providerFrame->StyleContext();
+    MOZ_ASSERT(newParent);
+
+    if (oldParent == newParent) {
+      // printf("\n\n\nunchanged style context keeps the same parent\n");
+#ifdef DEBUG
+      if (DebugRestyle()) {
+        PrintIndent();
+        printf("      skipping children, unchanged style context keeps the same parent\n");
+      }
+#endif
+      return;
+    }
+
+    // printf("\n\n\nmoving unchanged style context to new parent\n** before moving **\n");
+    // context->DumpStyleContextTreeStructs();
+
+//     for (nsIFrame* f = mFrame; f;
+//          f = GetNextContinuationWithSameStyle(f, context/*newContext*/)) {
+//       // printf("calling MoveStyleContexts on frame %p\n", f);
+//       MoveStyleContexts(f, oldParent, newParent);
+//     }
+    // oldParent->MoveChildrenTo(newParent);
+
+    for (nsIFrame* f = mFrame; f;
+         f = GetNextContinuationWithSameStyle(f, oldContext)) {
+      // printf("=> #%d moving old/new %p/%p\n", i, oldParent.get(), newParent.get());
+      // mMoveData.Append(f, oldParent, newParent);
+      oldParent->MoveChildrenTo(newParent);
+    }
+
+#ifdef DEBUG
+      if (DebugRestyle()) {
+        PrintIndent();
+        printf("      skipping subtree; will move children of style context %p to %p\n", oldParent.get(), newParent.get());
+      }
+#endif
+
+    if (!(mHintsHandled & nsChangeHint_ReconstructFrame)) {
+      InitializeAccessibilityNotifications();
+      SendAccessibilityNotifications();
+    }
+
+    // printf("** after moving **\n");
+    // context->DumpStyleContextTreeStructs();
+    return;
+  }
+
+  oldContext = nullptr;
+  oldParent = nullptr;
   RestyleChildren(childRestyleHint);
 }
 
-void
+bool
 ElementRestyler::RestyleSelf(nsIFrame* aSelf, nsRestyleHint aRestyleHint)
 {
   // XXXldb get new context from prev-in-flow if possible, to avoid
   // duplication.  (Or should we just let |GetContext| handle that?)
   // Getting the hint would be nice too, but that's harder.
 
   // XXXbryner we may be able to avoid some of the refcounting goop here.
   // We do need a reference to oldContext for the lifetime of this function, and it's possible
   // that the frame has the last reference to it, so AddRef it here.
 
+#ifdef DEBUG
+  if (DebugRestyle()) {
+    PrintIndent();
+    printf("      RestyleSelf ");
+    nsFrame::ListTag(stdout, aSelf);
+    printf(", aRestyleHint = ");
+    RestyleManager::PrintRestyleHint(aRestyleHint);
+    printf("\n");
+  }
+#endif
+
   nsChangeHint assumeDifferenceHint = NS_STYLE_HINT_NONE;
   nsRefPtr<nsStyleContext> oldContext = aSelf->StyleContext();
+  nsStyleContext* oldExtraContext = aSelf->GetAdditionalStyleContext(0);
   nsStyleSet* styleSet = mPresContext->StyleSet();
 
 #ifdef ACCESSIBILITY
   mWasFrameVisible = nsIPresShell::IsAccessibilityActive() ?
     oldContext->StyleVisibility()->IsVisible() : false;
 #endif
 
   nsIAtom* const pseudoTag = oldContext->GetPseudo();
   const nsCSSPseudoElements::Type pseudoType = oldContext->GetPseudoType();
 
+  bool childrenNeedNewStyleContexts = aRestyleHint;
+
+#ifdef DEBUG
+#define CHILDREN_NEEDED_CHECK_LOG(needed_) \
+  if (DebugRestyle()) {                                           \
+    PrintIndent();                                                \
+    printf("        must restyle subtree due to " #needed_ "\n"); \
+  }
+#else
+#define CHILDREN_NEEDED_CHECK_LOG(needed_) /* nothing */
+#endif
+
+#define CHILDREN_NEEDED_CHECK(needed_)              \
+  if (!childrenNeedNewStyleContexts && (needed_)) { \
+    childrenNeedNewStyleContexts = true;            \
+    CHILDREN_NEEDED_CHECK_LOG(needed_)              \
+  }
+
+  CHILDREN_NEEDED_CHECK(oldExtraContext)
+  CHILDREN_NEEDED_CHECK(oldContext->SharesStyleContextAllocatedObjectsWithParent())
+  CHILDREN_NEEDED_CHECK(oldContext->HasChildThatUsesGrandancestorStyle())
+  // this is for when we restyle a parent frame that has a shared style
+  // context, it has children that are shared, and we wouldn't restyle
+  // the other parent frames that share the style style context
+  CHILDREN_NEEDED_CHECK((mAncestorsAllHaveSharedStyle && oldContext->IsShared()))
+  CHILDREN_NEEDED_CHECK((pseudoTag && pseudoTag != nsCSSAnonBoxes::mozNonElement))
+  // this is for when mFrame is child of nsTableFrame; moving style
+  // context parents for the nsTableFrame (as a provider for
+  // nsOuterTableFrame) will cause nsStyleContext::GetContext not to
+  // return a new object for the nsOuterTableFrame, as it thinks it had
+  // the same parent as before
+  CHILDREN_NEEDED_CHECK((mFrame->GetParent() && mFrame->GetParent()->GetParent() && mFrame->GetParent()->GetParent()->GetParentStyleContextFrame() == mFrame->GetParent()))
+  // text node children of the after-::first-letter aren't getting the right parent
+  CHILDREN_NEEDED_CHECK(aSelf->GetType() == nsGkAtoms::letterFrame)
+  // placeholder frames prove tricky too
+  CHILDREN_NEEDED_CHECK(aSelf->GetType() == nsGkAtoms::placeholderFrame)
+
   nsStyleContext* parentContext;
   // Get the frame providing the parent style context.  If it is a
   // child, then resolve the provider first.
   nsIFrame* providerFrame = aSelf->GetParentStyleContextFrame();
   bool isChild = providerFrame && providerFrame->GetParent() == aSelf;
   if (!isChild) {
     if (providerFrame)
       parentContext = providerFrame->StyleContext();
@@ -2316,16 +2653,23 @@ ElementRestyler::RestyleSelf(nsIFrame* a
   else {
     MOZ_ASSERT(providerFrame->GetContent() == aSelf->GetContent(),
                "Postcondition for GetParentStyleContextFrame() violated. "
                "That means we need to add the current element to the "
                "ancestor filter.");
 
     // resolve the provider here (before aSelf below).
 
+#ifdef DEBUG
+    if (DebugRestyle()) {
+      PrintIndent();
+      printf("          resolving child provider frame\n");
+    }
+#endif
+
     // assumeDifferenceHint forces the parent's change to be also
     // applied to this frame, no matter what
     // nsStyleContext::CalcStyleDifference says. CalcStyleDifference
     // can't be trusted because it assumes any changes to the parent
     // style context provider will be automatically propagated to
     // the frame(s) with child style contexts.
 
     ElementRestyler providerRestyler(PARENT_CONTEXT_FROM_CHILD_FRAME,
@@ -2334,54 +2678,79 @@ ElementRestyler::RestyleSelf(nsIFrame* a
     assumeDifferenceHint = providerRestyler.HintsHandledForFrame();
 
     // The provider's new context becomes the parent context of
     // aSelf's context.
     parentContext = providerFrame->StyleContext();
     // Set |mResolvedChild| so we don't bother resolving the
     // provider again.
     mResolvedChild = providerFrame;
+
+    childrenNeedNewStyleContexts = true;
+    CHILDREN_NEEDED_CHECK_LOG(child provider frame)
   }
 
   if (providerFrame != aSelf->GetParent()) {
     // We don't actually know what the parent style context's
     // non-inherited hints were, so assume the worst.
     mParentFrameHintsNotHandledForDescendants =
       nsChangeHint_Hints_NotHandledForDescendants;
+
+    childrenNeedNewStyleContexts = true;
+    CHILDREN_NEEDED_CHECK_LOG(non-parent provider frame)
   }
 
+#ifdef DEBUG
+  if (DebugRestyle()) {
+    PrintIndent();
+    printf("        parentContext = %p\n", parentContext);
+  }
+#endif
+
   // do primary context
   nsRefPtr<nsStyleContext> newContext;
   nsIFrame *prevContinuation =
     GetPrevContinuationWithPossiblySameStyle(aSelf);
   nsStyleContext *prevContinuationContext;
   bool copyFromContinuation =
     prevContinuation &&
     (prevContinuationContext = prevContinuation->StyleContext())
       ->GetPseudo() == oldContext->GetPseudo() &&
      prevContinuationContext->GetParent() == parentContext;
   if (copyFromContinuation) {
     // Just use the style context from the frame's previous
     // continuation.
+#ifdef DEBUG
+    if (DebugRestyle()) {
+      PrintIndent();
+      printf("        using previous continuation's context\n");
+    }
+#endif
     newContext = prevContinuationContext;
   }
   else if (pseudoTag == nsCSSAnonBoxes::mozNonElement) {
     NS_ASSERTION(aSelf->GetContent(),
                  "non pseudo-element frame without content node");
     newContext = styleSet->ResolveStyleForNonElement(parentContext);
   }
   else if (!aRestyleHint && !prevContinuation) {
     // Unfortunately, if prevContinuation is non-null then we may have
     // already stolen the restyle tracker entry for this element while
     // processing prevContinuation.  So we don't know whether aRestyleHint
     // should really be 0 here or whether it should be eRestyle_Self.  Be
     // pessimistic and force an actual reresolve in that situation.  The good
     // news is that in the common case when prevContinuation is non-null we
     // just used prevContinuationContext anyway and aren't reaching this code
     // to start with.
+#ifdef DEBUG
+    if (DebugRestyle()) {
+      PrintIndent();
+      printf("        reparenting style context\n");
+    }
+#endif
     newContext =
       styleSet->ReparentStyleContext(oldContext, parentContext,
                                      ElementForStyleContext(mParentContent,
                                                             aSelf, pseudoType));
   } else if (pseudoType == nsCSSPseudoElements::ePseudo_AnonBox) {
     newContext = styleSet->ResolveAnonymousBoxStyle(pseudoTag,
                                                     parentContext);
   }
@@ -2439,48 +2808,169 @@ ElementRestyler::RestyleSelf(nsIFrame* a
         oldContext->IsLinkContext() == newContext->IsLinkContext() &&
         oldContext->RelevantLinkVisited() ==
           newContext->RelevantLinkVisited()) {
       // We're the root of the style context tree and the new style
       // context returned has the same rule node.  This means that
       // we can use FindChildWithRules to keep a lot of the old
       // style contexts around.  However, we need to start from the
       // same root.
+#ifdef DEBUG
+      if (DebugRestyle()) {
+        PrintIndent();
+        printf("        restyling root and keeping old context\n");
+      }
+#endif
       newContext = oldContext;
     }
+    childrenNeedNewStyleContexts = true;
+    CHILDREN_NEEDED_CHECK_LOG(no parent context)
   }
 
+#ifdef DEBUG
+  if (DebugRestyle()) {
+    PrintIndent();
+    printf("        oldContext = %p, newContext ", oldContext.get());
+    if (oldContext == newContext) {
+      printf("same\n");
+    } else {
+      printf("= %p\n", newContext.get());
+    }
+  }
+#endif
+
   if (newContext != oldContext) {
+    if (!childrenNeedNewStyleContexts) {
+      CHILDREN_NEEDED_CHECK(oldContext->RuleNode() != newContext->RuleNode())
+      CHILDREN_NEEDED_CHECK(oldContext->RuleNode() != newContext->RuleNode())
+      CHILDREN_NEEDED_CHECK(oldContext->IsLinkContext() != newContext->IsLinkContext())
+      CHILDREN_NEEDED_CHECK(oldContext->RelevantLinkVisited() != newContext->RelevantLinkVisited())
+      CHILDREN_NEEDED_CHECK(oldContext->GetPseudo() != newContext->GetPseudo())
+      CHILDREN_NEEDED_CHECK(oldContext->GetPseudoType() != newContext->GetPseudoType())
+    }
     if (!copyFromContinuation) {
       TryStartingTransition(mPresContext, aSelf->GetContent(),
                             oldContext, &newContext);
 
-      CaptureChange(oldContext, newContext, assumeDifferenceHint);
+      if (CaptureChange(oldContext, newContext, assumeDifferenceHint)) {
+        childrenNeedNewStyleContexts = true;
+        CHILDREN_NEEDED_CHECK_LOG(style differences)
+      }
+    } else {
+      bool anyChanges;
+      oldContext->CalcStyleDifference(newContext, nsChangeHint(0), anyChanges);
+      if (anyChanges) {
+        childrenNeedNewStyleContexts = true;
+        CHILDREN_NEEDED_CHECK_LOG(style differences)
+      }
     }
 
     if (!(mHintsHandled & nsChangeHint_ReconstructFrame)) {
       // If the frame gets regenerated, let it keep its old context,
       // which is important to maintain various invariants about
       // frame types matching their style contexts.
       // Note that this check even makes sense if we didn't call
       // CaptureChange because of copyFromContinuation being true,
       // since we'll have copied the existing context from the
       // previous continuation, so newContext == oldContext.
-      aSelf->SetStyleContext(newContext);
+#ifdef DEBUG
+      if (DebugRestyle()) {
+        PrintIndent();
+        printf("        setting new style context\n");
+      }
+#endif
+      if (!childrenNeedNewStyleContexts) {
+        CHILDREN_NEEDED_CHECK(oldContext->HasChildForPseudo())
+        CHILDREN_NEEDED_CHECK(oldContext->GetStyleIfVisited())
+        CHILDREN_NEEDED_CHECK(oldContext->GetParent() && oldContext->GetParent()->GetStyleIfVisited())
+        /*oldContext->HasChildWithStyleIfVisited()*/
+        uint32_t oldParentBits = (oldContext->GetParent()->mBits & NS_STYLE_INHERIT_MASK);
+        uint32_t newParentBits = (parentContext->mBits & NS_STYLE_INHERIT_MASK);
+        CHILDREN_NEEDED_CHECK(oldParentBits != newParentBits)
+      }
+#define STYLE_STRUCT(name_, checkdata_cb_) \
+  if (eStyleStruct_##name_ == sid) { \
+    printf(#name_ " %p", oldContext->GetParent()->PeekStyle##name_()); \
+    if (oldContext->GetParent()->mBits & nsCachedStyleData::GetBitForSID(sid)) { \
+      printf(" (dependent)"); \
+    } \
+    printf(" %p", parentContext->PeekStyle##name_()); \
+    if (parentContext->mBits & nsCachedStyleData::GetBitForSID(sid)) { \
+      printf(" (dependent)"); \
+    } \
+    printf("\n"); \
+  }
+      if (!childrenNeedNewStyleContexts) {
+        for (nsStyleStructID sid = nsStyleStructID_Inherited_Start;
+             sid < nsStyleStructID_Inherited_Start + nsStyleStructID_Inherited_Count;
+             sid = nsStyleStructID(sid + 1)) {
+          if ((oldContext->GetParent()->mBits & nsCachedStyleData::GetBitForSID(sid)) &&
+              !oldContext->GetParent()->HasSameCachedStyleData(parentContext, sid)) {
+            childrenNeedNewStyleContexts = true;
+#ifdef DEBUG
+            if (DebugRestyle()) {
+              PrintIndent();
+              printf("        old and new parents having mismatching style struct: ");
+#include "nsStyleStructList.h"
+            }
+#else
+            break;
+#endif
+          }
+        }
+      }
+      if (!childrenNeedNewStyleContexts) {
+        for (nsStyleStructID sid = nsStyleStructID_Reset_Start;
+             sid < nsStyleStructID_Reset_Start + nsStyleStructID_Reset_Count;
+             sid = nsStyleStructID(sid + 1)) {
+          if ((oldContext->GetParent()->mBits & nsCachedStyleData::GetBitForSID(sid)) &&
+              !oldContext->GetParent()->HasSameCachedStyleData(parentContext, sid)) {
+            childrenNeedNewStyleContexts = true;
+#ifdef DEBUG
+            if (DebugRestyle()) {
+              PrintIndent();
+              printf("        old and new parents having mismatching style struct: ");
+#include "nsStyleStructList.h"
+            }
+#else
+            break;
+#endif
+          }
+        }
+      }
+      if (childrenNeedNewStyleContexts /*|| true*/) {
+        // printf(" * setting new style context %p on frame %p\n", newContext.get(), aSelf);
+        aSelf->SetStyleContext(newContext);
+      } else {
+        // MOZ_ASSERT(oldContext->RuleNode() == newContext->RuleNode());
+        // printf(" * leaving old style context %p on frame %p\n", oldContext.get(), aSelf);
+        // newContext = oldContext;
+      }
+    } else {
+#ifdef DEBUG
+      if (DebugRestyle()) {
+        PrintIndent();
+        printf("        not setting new style context, since we'll reframe\n");
+      }
+#endif
     }
   }
   oldContext = nullptr;
 
   // do additional contexts
   // XXXbz might be able to avoid selector matching here in some
   // cases; won't worry about it for now.
   int32_t contextIndex = 0;
-  for (nsStyleContext* oldExtraContext;
-       (oldExtraContext = aSelf->GetAdditionalStyleContext(contextIndex));
-       ++contextIndex) {
+  while (oldExtraContext) {
+#ifdef DEBUG
+    if (DebugRestyle()) {
+      PrintIndent();
+      printf("        extra context %d\n", contextIndex);
+    }
+#endif
     nsRefPtr<nsStyleContext> newExtraContext;
     nsIAtom* const extraPseudoTag = oldExtraContext->GetPseudo();
     const nsCSSPseudoElements::Type extraPseudoType =
       oldExtraContext->GetPseudoType();
     NS_ASSERTION(extraPseudoTag &&
                  extraPseudoTag != nsCSSAnonBoxes::mozNonElement,
                  "extra style context is not pseudo element");
     if (extraPseudoType == nsCSSPseudoElements::ePseudo_AnonBox) {
@@ -2496,28 +2986,65 @@ ElementRestyler::RestyleSelf(nsIFrame* a
       newExtraContext = styleSet->ResolvePseudoElementStyle(mContent->AsElement(),
                                                             extraPseudoType,
                                                             newContext,
                                                             nullptr);
     }
 
     MOZ_ASSERT(newExtraContext);
 
+#ifdef DEBUG
+    if (DebugRestyle()) {
+      PrintIndent();
+      printf("          newExtraContext = %p\n", newExtraContext.get());
+    }
+#endif
+
     if (oldExtraContext != newExtraContext) {
       CaptureChange(oldExtraContext, newExtraContext, assumeDifferenceHint);
       if (!(mHintsHandled & nsChangeHint_ReconstructFrame)) {
+#ifdef DEBUG
+        if (DebugRestyle()) {
+          PrintIndent();
+          printf("          setting new extra style context\n");
+        }
+#endif
         aSelf->SetAdditionalStyleContext(contextIndex, newExtraContext);
+      } else {
+#ifdef DEBUG
+        if (DebugRestyle()) {
+          PrintIndent();
+          printf("          not setting new extra style context, since we'll "
+                 "reframe\n");
+        }
+#endif
       }
     }
+
+    oldExtraContext = aSelf->GetAdditionalStyleContext(++contextIndex);
   }
+
+#undef CHILDREN_NEEDED_CHECK
+#undef CHILDREN_NEEDED_CHECK_LOG
+
+  return childrenNeedNewStyleContexts;
 }
 
 void
 ElementRestyler::RestyleChildren(nsRestyleHint aChildRestyleHint)
 {
+#ifdef DEBUG
+  if (DebugRestyle()) {
+    PrintIndent();
+    printf("      RestyleChildren, aChildRestyleHint = ");
+    RestyleManager::PrintRestyleHint(aChildRestyleHint);
+    printf("\n");
+  }
+#endif
+
   RestyleUndisplayedChildren(aChildRestyleHint);
 
   // Check whether we might need to create a new ::before frame.
   // There's no need to do this if we're planning to reframe already
   // or if we're not forcing restyles on kids.
   // It's also important to check mHintsHandled since we use
   // mFrame->StyleContext(), which is out of date if mHintsHandled has a
   // ReconstructFrame hint.  Using an out of date style context could
@@ -2591,16 +3118,24 @@ ElementRestyler::RestyleUndisplayedChild
       NS_ASSERTION(undisplayedParent ||
                    undisplayed->mContent ==
                      mPresContext->Document()->GetRootElement(),
                    "undisplayed node child of null must be root");
       NS_ASSERTION(!undisplayed->mStyle->GetPseudo(),
                    "Shouldn't have random pseudo style contexts in the "
                    "undisplayed map");
 
+#ifdef DEBUG
+      if (DebugRestyle()) {
+        PrintIndent();
+        printf("        RestyleUndisplayedChildren: undisplayed->mContent = "
+               "%p\n", undisplayed->mContent.get());
+      }
+#endif
+
       // Get the parent of the undisplayed content and check if it is a XBL
       // children element. Push the children element as an ancestor here because it does
       // not have a frame and would not otherwise be pushed as an ancestor.
       nsIContent* parent = undisplayed->mContent->GetParent();
       TreeMatchContext::AutoAncestorPusher insertionPointPusher(mTreeMatchContext);
       if (parent && nsContentUtils::IsContentInsertionPoint(parent)) {
         insertionPointPusher.PushAncestorAndStyleScope(parent);
       }
@@ -2658,16 +3193,22 @@ ElementRestyler::RestyleBeforePseudo()
       // Checking for a :before frame is cheaper than getting the
       // :before style context.
       if (!nsLayoutUtils::GetBeforeFrame(mFrame) &&
           nsLayoutUtils::HasPseudoStyle(mFrame->GetContent(),
                                         mFrame->StyleContext(),
                                         nsCSSPseudoElements::ePseudo_before,
                                         mPresContext)) {
         // Have to create the new :before frame
+#ifdef DEBUG
+        if (DebugRestyle()) {
+          PrintIndent();
+          printf("        RestyleBeforePseudo, appending change\n");
+        }
+#endif
         NS_UpdateHint(mHintsHandled, nsChangeHint_ReconstructFrame);
         mChangeList->AppendChange(mFrame, mContent,
                                   nsChangeHint_ReconstructFrame);
       }
     }
   }
 }
 
@@ -2693,16 +3234,22 @@ ElementRestyler::RestyleAfterPseudo(nsIF
       // Getting the :after frame is more expensive than getting the pseudo
       // context, so get the pseudo context first.
       if (nsLayoutUtils::HasPseudoStyle(aFrame->GetContent(),
                                         aFrame->StyleContext(),
                                         nsCSSPseudoElements::ePseudo_after,
                                         mPresContext) &&
           !nsLayoutUtils::GetAfterFrame(aFrame)) {
         // have to create the new :after frame
+#ifdef DEBUG
+        if (DebugRestyle()) {
+          PrintIndent();
+          printf("        RestyleAfterPseudo, appending change\n");
+        }
+#endif
         NS_UpdateHint(mHintsHandled, nsChangeHint_ReconstructFrame);
         mChangeList->AppendChange(aFrame, mContent,
                                   nsChangeHint_ReconstructFrame);
       }
     }
   }
 }
 
@@ -2745,16 +3292,23 @@ ElementRestyler::InitializeAccessibility
   }
 #endif
 }
 
 void
 ElementRestyler::RestyleContentChildren(nsIFrame* aParent,
                                         nsRestyleHint aChildRestyleHint)
 {
+#ifdef DEBUG
+  if (DebugRestyle()) {
+    PrintIndent();
+    printf("        RestyleContentChildren\n");
+  }
+#endif
+
   nsIFrame::ChildListIterator lists(aParent);
   TreeMatchContext::AutoAncestorPusher ancestorPusher(mTreeMatchContext);
   if (!lists.IsDone()) {
     ancestorPusher.PushAncestorAndStyleScope(mContent);
   }
   for (; !lists.IsDone(); lists.Next()) {
     nsFrameList::Enumerator childFrames(lists.CurrentList());
     for (; !childFrames.AtEnd(); childFrames.Next()) {
@@ -2823,41 +3377,68 @@ ElementRestyler::SendAccessibilityNotifi
 #ifdef ACCESSIBILITY
   // Send notifications about visibility changes.
   if (mOurA11yNotification == eNotifyShown) {
     nsAccessibilityService* accService = nsIPresShell::AccService();
     if (accService) {
       nsIPresShell* presShell = mFrame->PresContext()->GetPresShell();
       nsIContent* content = mFrame->GetContent();
 
+#ifdef DEBUG
+      if (DebugRestyle()) {
+        printf("[eNotifyShown]\n  ContentRangeInserted ");
+        nsFrame::ListTag(stdout, mFrame);
+        printf("\n");
+      }
+#endif
       accService->ContentRangeInserted(presShell, content->GetParent(),
                                        content,
                                        content->GetNextSibling());
     }
   } else if (mOurA11yNotification == eNotifyHidden) {
     nsAccessibilityService* accService = nsIPresShell::AccService();
     if (accService) {
       nsIPresShell* presShell = mFrame->PresContext()->GetPresShell();
       nsIContent* content = mFrame->GetContent();
+#ifdef DEBUG
+      if (DebugRestyle()) {
+        printf("[eNotifyHidden]\n  ContentRemoved ");
+        nsFrame::ListTag(stdout, mFrame);
+        printf("\n");
+      }
+#endif
       accService->ContentRemoved(presShell, content->GetParent(), content);
 
       // Process children staying shown.
       uint32_t visibleContentCount = mVisibleKidsOfHiddenElement.Length();
       for (uint32_t idx = 0; idx < visibleContentCount; idx++) {
         nsIContent* childContent = mVisibleKidsOfHiddenElement[idx];
+        printf("  ContentRangeInserted (visible kid) %p\n", childContent);
         accService->ContentRangeInserted(presShell, childContent->GetParent(),
                                          childContent,
                                          childContent->GetNextSibling());
       }
       mVisibleKidsOfHiddenElement.Clear();
     }
   }
 #endif
 }
 
+#ifdef DEBUG
+void
+ElementRestyler::DoPrintIndent()
+{
+  for (int32_t i = 0; i < mDepth; i++) {
+    printf("    ");
+  }
+}
+#endif
+
+uint32_t gMaxStyleContextsToMoveLength = 0;
+
 static inline nsIFrame*
 GetNextBlockInInlineSibling(FramePropertyTable* aPropTable, nsIFrame* aFrame)
 {
   NS_ASSERTION(!aFrame->GetPrevContinuation(),
                "must start with the first continuation");
   // Might we have ib-split siblings?
   if (!(aFrame->GetStateBits() & NS_FRAME_PART_OF_IBSPLIT)) {
     // nothing more to do here
@@ -2901,39 +3482,143 @@ RestyleManager::ComputeStyleChangeFor(ns
   TreeMatchContext treeMatchContext(true,
                                     nsRuleWalker::eRelevantLinkUnvisited,
                                     mPresContext->Document());
   nsIContent *parent = content ? content->GetParent() : nullptr;
   Element *parentElement =
     parent && parent->IsElement() ? parent->AsElement() : nullptr;
   treeMatchContext.InitAncestors(parentElement);
   nsTArray<nsIContent*> visibleKidsOfHiddenElement;
+  StyleContextMoveData moveData;
   for (nsIFrame* ibSibling = aFrame; ibSibling;
        ibSibling = GetNextBlockInInlineSibling(propTable, ibSibling)) {
     // Outer loop over ib-split siblings
     for (nsIFrame* cont = ibSibling; cont; cont = cont->GetNextContinuation()) {
       if (GetPrevContinuationWithSameStyle(cont)) {
         // We already handled this element when dealing with its earlier
         // continuation.
         continue;
       }
 
       // Inner loop over next-in-flows of the current frame
       ElementRestyler restyler(mPresContext, cont, aChangeList,
                                aMinChange, aRestyleTracker,
                                treeMatchContext,
-                               visibleKidsOfHiddenElement);
+                               visibleKidsOfHiddenElement,
+                               moveData);
 
       restyler.Restyle(aRestyleDescendants ? eRestyle_Subtree : eRestyle_Self);
 
       if (restyler.HintsHandledForFrame() & nsChangeHint_ReconstructFrame) {
         // If it's going to cause a framechange, then don't bother
         // with the continuations or ib-split siblings since they'll be
         // clobbered by the frame reconstruct anyway.
         NS_ASSERTION(!cont->GetPrevContinuation(),
                      "continuing frame had more severe impact than first-in-flow");
         return;
       }
     }
   }
+  gMaxStyleContextsToMoveLength = std::max(gMaxStyleContextsToMoveLength, moveData.Length());
+  for (uint32_t i = 0; i < moveData.Length(); i++) {
+    // const StyleContextMoveData::Entry& entry = moveData[i];
+    // entry.from->MoveChildrenTo(entry.to);
+
+    // MoveStyleContexts(entry.frame, entry.from, entry.to);
+  }
 }
 
+#ifdef DEBUG
+void
+RestyleManager::DoPrintRestyleHint(nsRestyleHint aHint)
+{
+  bool any = false;
+  const char* names[] = { "Self", "Subtree", "LaterSiblings" };
+  uint32_t hint = aHint & ((1 << ArrayLength(names)) - 1);
+  uint32_t rest = aHint & ~((1 << ArrayLength(names)) - 1);
+  for (uint32_t i = 0; i < ArrayLength(names); i++) {
+    if (hint & (1 << i)) {
+      if (any) {
+        printf(" | ");
+      }
+      printf("eRestyle_%s", names[i]);
+      any = true;
+    }
+  }
+  if (rest) {
+    if (any) {
+      printf(" | ");
+    }
+    printf("0x%0x", rest);
+  } else {
+    if (!any) {
+      printf("0");
+    }
+  }
+}
+
+void
+RestyleManager::DoPrintChangeHint(nsChangeHint aHint)
+{
+  bool any = false;
+  const char* names[] = {
+    "RepaintFrame", "NeedReflow", "ClearAncestorIntrinsics",
+    "ClearDescendantIntrinsics", "NeedDirtyReflow", "SyncFrameView",
+    "UpdateCursor", "UpdateEffects", "UpdateOpacityLayer",
+    "UpdateTransformLayer", "ReconstructFrame", "UpdateOverflow",
+    "ChildrenOnlyTransform", "RecomputePosition", "AddOrRemoveTransform",
+    "BorderStyleNoneChange", "NeutralChange", "InheritedNeutralChange",
+    "UpdateTextPath"
+  };
+  uint32_t hint = aHint & ((1 << ArrayLength(names)) - 1);
+  uint32_t rest = aHint & ~((1 << ArrayLength(names)) - 1);
+  if (hint == nsChangeHint_Hints_NotHandledForDescendants) {
+    printf("nsChangeHint_Hints_NotHandledForDescendants");
+    hint = 0;
+    any = true;
+  } else {
+    if ((hint & NS_STYLE_HINT_FRAMECHANGE) == NS_STYLE_HINT_FRAMECHANGE) {
+      printf("NS_STYLE_HINT_FRAMECHANGE");
+      hint = hint & ~NS_STYLE_HINT_FRAMECHANGE;
+      any = true;
+    } else if ((hint & NS_STYLE_HINT_REFLOW) == NS_STYLE_HINT_REFLOW) {
+      printf("NS_STYLE_HINT_REFLOW");
+      hint = hint & ~NS_STYLE_HINT_REFLOW;
+      any = true;
+    } else if ((hint & nsChangeHint_AllReflowHints) == nsChangeHint_AllReflowHints) {
+      printf("nsChangeHint_AllReflowHints");
+      hint = hint & ~nsChangeHint_AllReflowHints;
+      any = true;
+    } else if ((hint & NS_STYLE_HINT_VISUAL) == NS_STYLE_HINT_VISUAL) {
+      printf("NS_STYLE_HINT_VISUAL");
+      hint = hint & ~NS_STYLE_HINT_VISUAL;
+      any = true;
+    }
+  }
+  for (uint32_t i = 0; i < ArrayLength(names); i++) {
+    if (hint & (1 << i)) {
+      if (any) {
+        printf(" | ");
+      }
+      printf("nsChangeHint_%s", names[i]);
+      any = true;
+    }
+  }
+  if (rest) {
+    if (any) {
+      printf(" | ");
+    }
+    printf("0x%0x", rest);
+  } else {
+    if (!any) {
+      printf("NS_STYLE_HINT_NONE");
+    }
+  }
+}
+
+void
+RestyleManager::DumpRuleTreeStructs()
+{
+  mPresContext->StyleSet()->GetRuleTree()->DumpRuleTreeStructs();
+}
+#endif
+
 } // namespace mozilla
diff --git a/layout/base/RestyleManager.h b/layout/base/RestyleManager.h
--- a/layout/base/RestyleManager.h
+++ b/layout/base/RestyleManager.h
@@ -185,16 +185,27 @@ public:
     PostRestyleEventInternal(true);
   }
 
   void FlushOverflowChangedTracker()
   {
     mOverflowChangedTracker.Flush();
   }
 
+  static void PrintRestyleHint(nsRestyleHint aHint) {
+#ifdef DEBUG
+    DoPrintRestyleHint(aHint);
+#endif
+  }
+  static void PrintChangeHint(nsChangeHint aHint) {
+#ifdef DEBUG
+    DoPrintChangeHint(aHint);
+#endif
+  }
+
 private:
   /**
    * Notify the frame constructor that an element needs to have its
    * style recomputed.
    * @param aElement: The element to be restyled.
    * @param aRestyleHint: Which nodes need to have selector matching run
    *                      on them.
    * @param aMinChangeHint: A minimum change hint for aContent and its
@@ -220,32 +231,68 @@ public:
    * This method is used to recompute the style data when some change happens
    * outside of any style rules, like a color preference change or a change
    * in a system font size, or to fix things up when an optimization in the
    * style data has become invalid. We assume that the root frame will not
    * need to be reframed.
    */
   void PostRebuildAllStyleDataEvent(nsChangeHint aExtraHint);
 
+#ifdef DEBUG
+  bool DebugRestyle() {
+    return DebugRestyle(mPresContext);
+  }
+
+  static bool DebugRestyle(nsPresContext* aPresContext) {
+    return aPresContext->DebugRestyle() &&
+           (!aPresContext->IsProcessingAnimationStyleChange() ||
+            DebugRestyleAnimationsEnabled());
+  }
+
+  static bool DebugRestyleInitiallyEnabled() {
+    static bool enabled = getenv("MOZ_DEBUG_RESTYLE") != 0;
+    return enabled;
+  }
+
+  static bool DebugRestyleAnimationsEnabled() {
+    static bool animations = getenv("MOZ_DEBUG_RESTYLE_ANIMATIONS") != 0;
+    return animations;
+  }
+
+  void DumpRuleTreeStructs();
+#endif
+
+  void MoveStyleContext(nsIFrame* aFrame,
+                         nsStyleContext* aOldParent,
+                         nsStyleContext* aNewParent);
+  void MoveStyleContexts(nsIFrame* aFrame,
+                         nsStyleContext* aOldParent,
+                         nsStyleContext* aNewParent);
+
 private:
   /* aMinHint is the minimal change that should be made to the element */
   // XXXbz do we really need the aPrimaryFrame argument here?
   void RestyleElement(Element*        aElement,
                       nsIFrame*       aPrimaryFrame,
                       nsChangeHint    aMinHint,
                       RestyleTracker& aRestyleTracker,
                       bool            aRestyleDescendants);
 
   nsresult StyleChangeReflow(nsIFrame* aFrame, nsChangeHint aHint);
 
   // Returns true if this function managed to successfully move a frame, and
   // false if it could not process the position change, and a reflow should
   // be performed instead.
   bool RecomputePosition(nsIFrame* aFrame);
 
+#ifdef DEBUG
+  static void DoPrintRestyleHint(nsRestyleHint aHint);
+  static void DoPrintChangeHint(nsChangeHint aHint);
+#endif
+
 private:
   nsPresContext* mPresContext; // weak, disconnected in Disconnect
 
   bool mRebuildAllStyleData : 1;
   // True if we're already waiting for a refresh notification
   bool mObservingRefreshDriver : 1;
   // True if we're in the middle of a nsRefreshDriver refresh
   bool mInStyleRefresh : 1;
@@ -257,32 +304,61 @@ private:
   // The total number of animation flushes by this frame constructor.
   // Used to keep the layer and animation manager in sync.
   uint64_t mAnimationGeneration;
 
   RestyleTracker mPendingRestyles;
   RestyleTracker mPendingAnimationRestyles;
 };
 
+class StyleContextMoveData
+{
+public:
+  struct Entry {
+    Entry(nsIFrame* aFrame, nsStyleContext* aFrom, nsStyleContext* aTo)
+      : frame(aFrame), from(aFrom), to(aTo) { }
+
+    nsIFrame* frame;
+    nsRefPtr<nsStyleContext> from;
+    nsRefPtr<nsStyleContext> to;
+  };
+
+  void Append(nsIFrame* aFrame, nsStyleContext* aFrom, nsStyleContext* aTo) {
+    mEntries.AppendElement(Entry(aFrame, aFrom, aTo));
+  }
+
+  uint32_t Length() {
+    return mEntries.Length();
+  }
+
+  const Entry& operator[](uint32_t aIndex) {
+    return mEntries[aIndex];
+  }
+
+private:
+  nsTArray<Entry> mEntries;
+};
+
 /**
  * An ElementRestyler is created for *each* element in a subtree that we
  * recompute styles for.
  */
 class ElementRestyler MOZ_FINAL {
 public:
   typedef mozilla::dom::Element Element;
 
   // Construct for the root of the subtree that we're restyling.
   ElementRestyler(nsPresContext* aPresContext,
                   nsIFrame* aFrame,
                   nsStyleChangeList* aChangeList,
                   nsChangeHint aHintsHandledByAncestors,
                   RestyleTracker& aRestyleTracker,
                   TreeMatchContext& aTreeMatchContext,
-                  nsTArray<nsIContent*>& aVisibleKidsOfHiddenElement);
+                  nsTArray<nsIContent*>& aVisibleKidsOfHiddenElement,
+                  StyleContextMoveData& aMoveData);
 
   // Construct for an element whose parent is being restyled.
   enum ConstructorFlags {
     FOR_OUT_OF_FLOW_CHILD = 1<<0
   };
   ElementRestyler(const ElementRestyler& aParentRestyler,
                   nsIFrame* aFrame,
                   uint32_t aConstructorFlags);
@@ -293,16 +369,18 @@ public:
   // as the parent style context for their outer table frame (table
   // wrapper frame).  We should probably try to get rid of this
   // exception and have the inheritance go the other way.)
   enum ParentContextFromChildFrame { PARENT_CONTEXT_FROM_CHILD_FRAME };
   ElementRestyler(ParentContextFromChildFrame,
                   const ElementRestyler& aParentFrameRestyler,
                   nsIFrame* aFrame);
 
+  ~ElementRestyler();
+
   /**
    * Restyle our frame's element and its subtree.
    *
    * Use eRestyle_Self for the aRestyleHint argument to mean
    * "reresolve our style context but not kids", use eRestyle_Subtree
    * to mean "reresolve our style context and kids", and use
    * nsRestyleHint(0) to mean recompute a new style context for our
    * current parent and existing rulenode, and the same for kids.
@@ -313,33 +391,39 @@ public:
    * mHintsHandled changes over time; it starts off as the hints that
    * have been handled by ancestors, and by the end of Restyle it
    * represents the hints that have been handled for this frame.  This
    * method is intended to be called after Restyle, to find out what
    * hints have been handled for this frame.
    */
   nsChangeHint HintsHandledForFrame() { return mHintsHandled; }
 
+#ifdef DEBUG
+  bool DebugRestyle() {
+    return RestyleManager::DebugRestyle(mPresContext);
+  }
+#endif
+
 private:
   /**
    * First half of Restyle().
    */
-  void RestyleSelf(nsIFrame* aSelf, nsRestyleHint aRestyleHint);
+  bool RestyleSelf(nsIFrame* aSelf, nsRestyleHint aRestyleHint);
 
   /**
    * Restyle the children of this frame (and, in turn, their children).
    *
    * Second half of Restyle().
    */
   void RestyleChildren(nsRestyleHint aChildRestyleHint);
 
   /**
-   * Helper for RestyleSelf().
+   * Helpers for RestyleSelf().
    */
-  void CaptureChange(nsStyleContext* aOldContext,
+  bool CaptureChange(nsStyleContext* aOldContext,
                      nsStyleContext* aNewContext,
                      nsChangeHint aChangeToAssume);
 
   /**
    * Helpers for RestyleChildren().
    */
   void RestyleUndisplayedChildren(nsRestyleHint aChildRestyleHint);
   void RestyleBeforePseudo();
@@ -356,16 +440,26 @@ private:
   };
 
   enum A11yNotificationType {
     eDontNotify,
     eNotifyShown,
     eNotifyHidden
   };
 
+  void PrintIndent() {
+#ifdef DEBUG
+    DoPrintIndent();
+#endif
+  }
+
+#ifdef DEBUG
+  void DoPrintIndent();
+#endif
+
 private:
   nsPresContext* const mPresContext;
   nsIFrame* const mFrame;
   nsIContent* const mParentContent;
   // |mContent| is the node that we used for rule matching of
   // normal elements (not pseudo-elements) and for which we generate
   // framechange hints if we need them.
   nsIContent* const mContent;
@@ -377,21 +471,31 @@ private:
   // style comparision returns a hint other than one of these hints.
   nsChangeHint mHintsHandled;
   // See nsStyleContext::CalcStyleDifference
   nsChangeHint mParentFrameHintsNotHandledForDescendants;
   nsChangeHint mHintsNotHandledForDescendants;
   RestyleTracker& mRestyleTracker;
   TreeMatchContext& mTreeMatchContext;
   nsIFrame* mResolvedChild; // child that provides our parent style context
+  nsStyleContext* mAncestorOldStyleContext;
+  nsStyleContext* mAncestorNewStyleContext;
+  bool mAncestorOldStyleContextWasAddRefed;
+  bool mAncestorsAllHaveSharedStyle;
 
 #ifdef ACCESSIBILITY
   const DesiredA11yNotifications mDesiredA11yNotifications;
   DesiredA11yNotifications mKidsDesiredA11yNotifications;
   A11yNotificationType mOurA11yNotification;
   nsTArray<nsIContent*>& mVisibleKidsOfHiddenElement;
   bool mWasFrameVisible;
 #endif
+
+  StyleContextMoveData& mMoveData;
+
+#ifdef DEBUG
+  int32_t mDepth;
+#endif
 };
 
 } // namespace mozilla
 
 #endif /* mozilla_RestyleManager_h */
diff --git a/layout/base/RestyleTracker.cpp b/layout/base/RestyleTracker.cpp
--- a/layout/base/RestyleTracker.cpp
+++ b/layout/base/RestyleTracker.cpp
@@ -7,16 +7,17 @@
  * A class which manages pending restyles.  This handles keeping track
  * of what nodes restyles need to happen on and so forth.
  */
 
 #include "RestyleTracker.h"
 #include "nsStyleChangeList.h"
 #include "RestyleManager.h"
 #include "GeckoProfiler.h"
+#include "nsFrame.h"
 
 namespace mozilla {
 
 inline nsIDocument*
 RestyleTracker::Document() const {
   return mRestyleManager->PresContext()->Document();
 }
 
@@ -44,19 +45,38 @@ CollectLaterSiblings(nsISupports* aEleme
       element->HasFlag(collector->tracker->RestyleBit()) &&
       (aData.mRestyleHint & eRestyle_LaterSiblings)) {
     collector->elements->AppendElement(element);
   }
 
   return PL_DHASH_NEXT;
 }
 
+#ifdef DEBUG
+static void
+ListTag(dom::Element* aElement)
+{
+  nsIFrame* frame = aElement->GetPrimaryFrame();
+  if (frame) {
+    nsFrame::ListTag(stdout, frame);
+  } else {
+    nsAutoString buf;
+    aElement->Tag()->ToString(buf);
+    printf("(%s@%p)", NS_LossyConvertUTF16toASCII(buf).get(), aElement);
+  }
+}
+#endif
+
 struct RestyleCollector {
   RestyleTracker* tracker;
   RestyleTracker::RestyleEnumerateData** restyleArrayPtr;
+#ifdef DEBUG
+  uint32_t count;
+  bool log;
+#endif
 };
 
 static PLDHashOperator
 CollectRestyles(nsISupports* aElement,
                 RestyleTracker::RestyleData& aData,
                 void* aRestyleCollector)
 {
   dom::Element* element =
@@ -64,16 +84,23 @@ CollectRestyles(nsISupports* aElement,
   RestyleCollector* collector =
     static_cast<RestyleCollector*>(aRestyleCollector);
   // Only collect the entries that actually need restyling by us (and
   // haven't, for example, already been restyled).
   // It's important to not mess with the flags on entries not in our
   // document.
   if (element->GetCurrentDoc() != collector->tracker->Document() ||
       !element->HasFlag(collector->tracker->RestyleBit())) {
+#ifdef DEBUG
+    if (collector->log) {
+      printf("  skipping pending restyle ");
+      ListTag(element);
+      printf(", already restyled or no longer in the document\n");
+    }
+#endif
     return PL_DHASH_NEXT;
   }
 
   NS_ASSERTION(!element->HasFlag(collector->tracker->RootBit()) ||
                // Maybe we're just not reachable via the frame tree?
                (element->GetFlattenedTreeParent() &&
                 (!element->GetFlattenedTreeParent()->GetPrimaryFrame()||
                  element->GetFlattenedTreeParent()->GetPrimaryFrame()->IsLeaf())) ||
@@ -94,16 +121,20 @@ CollectRestyles(nsISupports* aElement,
   RestyleTracker::RestyleEnumerateData** restyleArrayPtr =
     collector->restyleArrayPtr;
   RestyleTracker::RestyleEnumerateData* currentRestyle =
     *restyleArrayPtr;
   currentRestyle->mElement = element;
   currentRestyle->mRestyleHint = aData.mRestyleHint;
   currentRestyle->mChangeHint = aData.mChangeHint;
 
+#ifdef DEBUG
+  collector->count++;
+#endif
+
   // Increment to the next slot in the array
   *restyleArrayPtr = currentRestyle + 1;
 
   return PL_DHASH_NEXT;
 }
 
 inline void
 RestyleTracker::ProcessOneRestyle(Element* aElement,
@@ -111,56 +142,97 @@ RestyleTracker::ProcessOneRestyle(Elemen
                                   nsChangeHint aChangeHint)
 {
   NS_PRECONDITION((aRestyleHint & eRestyle_LaterSiblings) == 0,
                   "Someone should have handled this before calling us");
   NS_PRECONDITION(Document(), "Must have a document");
   NS_PRECONDITION(aElement->GetCurrentDoc() == Document(),
                   "Element has unexpected document");
 
+#ifdef DEBUG
+  if (DebugRestyle()) {
+    printf("    aRestyleHint = ");
+    RestyleManager::PrintRestyleHint(aRestyleHint);
+    printf(", aChangeHint = ");
+    RestyleManager::PrintChangeHint(aChangeHint);
+    printf("\n");
+  }
+#endif
+
   nsIFrame* primaryFrame = aElement->GetPrimaryFrame();
   if (aRestyleHint & (eRestyle_Self | eRestyle_Subtree)) {
     mRestyleManager->RestyleElement(aElement, primaryFrame, aChangeHint,
                                     *this,
                                     (aRestyleHint & eRestyle_Subtree) != 0);
   } else if (aChangeHint &&
              (primaryFrame ||
               (aChangeHint & nsChangeHint_ReconstructFrame))) {
     // Don't need to recompute style; just apply the hint
     nsStyleChangeList changeList;
     changeList.AppendChange(primaryFrame, aElement, aChangeHint);
     mRestyleManager->ProcessRestyledFrames(changeList);
   }
+
+  /*printf("-- After one restyle: --");
+  primaryFrame = aElement->GetPrimaryFrame();
+  nsStyleContext* root = primaryFrame ? primaryFrame->StyleContext() : nullptr;
+  if (root) {
+    while (root->GetParent()) {
+      root = root->GetParent();
+    }
+    root->DumpStyleContextTreeStructs();
+  }
+  mRestyleManager->DumpRuleTreeStructs();*/
 }
 
 void
 RestyleTracker::DoProcessRestyles()
 {
   PROFILER_LABEL("CSS", "ProcessRestyles");
 
   mRestyleManager->BeginProcessingRestyles();
 
+#ifdef DEBUG
+  if (DebugRestyle()) {
+    printf("Processing %d pending ", mPendingRestyles.Count());
+    if (mRestyleManager->PresContext()->IsProcessingAnimationStyleChange()) {
+      printf("animation ");
+    }
+    printf("restyles with %d restyle roots\n", mRestyleRoots.Length());
+  }
+#endif
+
   // loop so that we process any restyle events generated by processing
   while (mPendingRestyles.Count()) {
     if (mHaveLaterSiblingRestyles) {
       // Convert them to individual restyles on all the later siblings
       nsAutoTArray<nsRefPtr<Element>, RESTYLE_ARRAY_STACKSIZE> laterSiblingArr;
       LaterSiblingCollector siblingCollector = { this, &laterSiblingArr };
       mPendingRestyles.Enumerate(CollectLaterSiblings, &siblingCollector);
       for (uint32_t i = 0; i < laterSiblingArr.Length(); ++i) {
         Element* element = laterSiblingArr[i];
         for (nsIContent* sibling = element->GetNextSibling();
              sibling;
              sibling = sibling->GetNextSibling()) {
-          if (sibling->IsElement() &&
-              AddPendingRestyle(sibling->AsElement(), eRestyle_Subtree,
-                                NS_STYLE_HINT_NONE)) {
+          if (sibling->IsElement()) {
+#ifdef DEBUG
+            if (DebugRestyle()) {
+              printf("  adding pending restyle for ");
+              ListTag(sibling->AsElement());
+              printf(" due to eRestyle_LaterSiblings hint on ");
+              ListTag(element->AsElement());
+              printf("\n");
+            }
+#endif
+            if (AddPendingRestyle(sibling->AsElement(), eRestyle_Subtree,
+                                  NS_STYLE_HINT_NONE)) {
               // Nothing else to do here; we'll handle the following
               // siblings when we get to |sibling| in laterSiblingArr.
-            break;
+              break;
+            }
           }
         }
       }
 
       // Now remove all those eRestyle_LaterSiblings bits
       for (uint32_t i = 0; i < laterSiblingArr.Length(); ++i) {
         Element* element = laterSiblingArr[i];
         NS_ASSERTION(element->HasFlag(RestyleBit()), "How did that happen?");
@@ -171,43 +243,75 @@ RestyleTracker::DoProcessRestyles()
           mPendingRestyles.Get(element, &data);
         NS_ASSERTION(found, "Where did our entry go?");
         data.mRestyleHint =
           nsRestyleHint(data.mRestyleHint & ~eRestyle_LaterSiblings);
 
         mPendingRestyles.Put(element, data);
       }
 
+#ifdef DEBUG
+    if (DebugRestyle()) {
+        printf("  %d pending restyles after expanding out "
+               "eRestyle_LaterSiblings\n", mPendingRestyles.Count());
+    }
+#endif
+
       mHaveLaterSiblingRestyles = false;
     }
 
     uint32_t rootCount;
     while ((rootCount = mRestyleRoots.Length())) {
       // Make sure to pop the element off our restyle root array, so
       // that we can freely append to the array as we process this
       // element.
       nsRefPtr<Element> element;
       element.swap(mRestyleRoots[rootCount - 1]);
       mRestyleRoots.RemoveElementAt(rootCount - 1);
 
+#ifdef DEBUG
+      if (DebugRestyle()) {
+        printf("  processing style root ");
+        ListTag(element);
+        printf(" at index %d\n", rootCount - 1);
+      }
+#endif
+
       // Do the document check before calling GetRestyleData, since we
       // don't want to do the sibling-processing GetRestyleData does if
       // the node is no longer relevant.
       if (element->GetCurrentDoc() != Document()) {
         // Content node has been removed from our document; nothing else
         // to do here
+#ifdef DEBUG
+        if (DebugRestyle()) {
+          printf("    skipping, no longer in the document\n");
+        }
+#endif
         continue;
       }
 
       RestyleData data;
       if (!GetRestyleData(element, &data)) {
+#ifdef DEBUG
+        if (DebugRestyle()) {
+          printf("    skipping, already restyled\n");
+        }
+#endif
         continue;
       }
 
       ProcessOneRestyle(element, data.mRestyleHint, data.mChangeHint);
+
+      for (uint32_t i = 0; i < data.mDescendants.Length(); ++i) {
+        Element* descendant = data.mDescendants[i];
+        if (descendant->HasFlag(RestyleBit())) {
+          mRestyleRoots.AppendElement(descendant);
+        }
+      }
     }
 
     if (mHaveLaterSiblingRestyles) {
       // Keep processing restyles for now
       continue;
     }
 
     // Now we only have entries with change hints left.  To be safe in
@@ -216,27 +320,43 @@ RestyleTracker::DoProcessRestyles()
     // enumerating the hashtable.  Use the stack if we can, otherwise
     // fall back on heap-allocation.
     nsAutoTArray<RestyleEnumerateData, RESTYLE_ARRAY_STACKSIZE> restyleArr;
     RestyleEnumerateData* restylesToProcess =
       restyleArr.AppendElements(mPendingRestyles.Count());
     if (restylesToProcess) {
       RestyleEnumerateData* lastRestyle = restylesToProcess;
       RestyleCollector collector = { this, &lastRestyle };
+#ifdef DEBUG
+      collector.log = DebugRestyle();
+#endif
       mPendingRestyles.Enumerate(CollectRestyles, &collector);
 
       // Clear the hashtable now that we don't need it anymore
       mPendingRestyles.Clear();
 
+#ifdef DEBUG
+      uint32_t index = 0;
+#endif
       for (RestyleEnumerateData* currentRestyle = restylesToProcess;
            currentRestyle != lastRestyle;
            ++currentRestyle) {
+#ifdef DEBUG
+        if (DebugRestyle()) {
+          printf("  processing pending restyle ");
+          ListTag(currentRestyle->mElement);
+          printf(" at index %d/%d\n", index, collector.count);
+        }
+        index++;
+#endif
         ProcessOneRestyle(currentRestyle->mElement,
                           currentRestyle->mRestyleHint,
                           currentRestyle->mChangeHint);
+
+        MOZ_ASSERT(currentRestyle->mDescendants.IsEmpty());
       }
     }
   }
 
   mRestyleManager->EndProcessingRestyles();
 }
 
 bool
@@ -259,22 +379,31 @@ RestyleTracker::GetRestyleData(Element* 
   if (aData->mRestyleHint & eRestyle_LaterSiblings) {
     // Someone readded the eRestyle_LaterSiblings hint for this
     // element.  Leave it around for now, but remove the other restyle
     // hints and the change hint for it.  Also unset its root bit,
     // since it's no longer a root with the new restyle data.
     RestyleData newData;
     newData.mChangeHint = nsChangeHint(0);
     newData.mRestyleHint = eRestyle_LaterSiblings;
+    newData.mDescendants.SwapElements(aData->mDescendants);
     mPendingRestyles.Put(aElement, newData);
     aElement->UnsetFlags(RootBit());
     aData->mRestyleHint =
       nsRestyleHint(aData->mRestyleHint & ~eRestyle_LaterSiblings);
   } else {
     mPendingRestyles.Remove(aElement);
     aElement->UnsetFlags(mRestyleBits);
   }
 
   return true;
 }
 
+#ifdef DEBUG
+bool
+RestyleTracker::DebugRestyle()
+{
+  return mRestyleManager->DebugRestyle();
+}
+#endif
+
 } // namespace mozilla
 
diff --git a/layout/base/RestyleTracker.h b/layout/base/RestyleTracker.h
--- a/layout/base/RestyleTracker.h
+++ b/layout/base/RestyleTracker.h
@@ -253,18 +253,19 @@ public:
   }
 
   // Return our ELEMENT_IS_POTENTIAL_(ANIMATION_)RESTYLE_ROOT bit
   uint32_t RootBit() const {
     return mRestyleBits & ~ELEMENT_PENDING_RESTYLE_FLAGS;
   }
   
   struct RestyleData {
-    nsRestyleHint mRestyleHint;  // What we want to restyle
-    nsChangeHint  mChangeHint;   // The minimal change hint for "self"
+    nsRestyleHint mRestyleHint;       // What we want to restyle
+    nsChangeHint mChangeHint;         // The minimal change hint for "self"
+    nsTArray<Element*> mDescendants;  // ...
   };
 
   /**
    * If the given Element has a restyle pending for it, return the
    * relevant restyle data.  This function will clear everything other
    * than a possible eRestyle_LaterSiblings hint for aElement out of
    * our hashtable.  The returned aData will never have an
    * eRestyle_LaterSiblings hint in it.
@@ -279,16 +280,20 @@ public:
    * The document we're associated with.
    */
   inline nsIDocument* Document() const;
 
   struct RestyleEnumerateData : public RestyleData {
     nsRefPtr<Element> mElement;
   };
 
+#ifdef DEBUG
+  bool DebugRestyle();
+#endif
+
 private:
   /**
    * Handle a single mPendingRestyles entry.  aRestyleHint must not
    * include eRestyle_LaterSiblings; that needs to be dealt with
    * before calling this function.
    */
   inline void ProcessOneRestyle(Element* aElement,
                                 nsRestyleHint aRestyleHint,
@@ -324,16 +329,17 @@ private:
   // for such entries when we can't possibly have any.
   bool mHaveLaterSiblingRestyles;
 };
 
 inline bool RestyleTracker::AddPendingRestyle(Element* aElement,
                                                 nsRestyleHint aRestyleHint,
                                                 nsChangeHint aMinChangeHint)
 {
+  // printf("AddPendingRestyle aElement=%p\n", aElement);
   RestyleData existingData;
   existingData.mRestyleHint = nsRestyleHint(0);
   existingData.mChangeHint = NS_STYLE_HINT_NONE;
 
   // Check the RestyleBit() flag before doing the hashtable Get, since
   // it's possible that the data in the hashtable isn't actually
   // relevant anymore (if the flag is not set).
   if (aElement->HasFlag(RestyleBit())) {
@@ -343,24 +349,23 @@ inline bool RestyleTracker::AddPendingRe
   }
 
   bool hadRestyleLaterSiblings =
     (existingData.mRestyleHint & eRestyle_LaterSiblings) != 0;
   existingData.mRestyleHint =
     nsRestyleHint(existingData.mRestyleHint | aRestyleHint);
   NS_UpdateHint(existingData.mChangeHint, aMinChangeHint);
 
-  mPendingRestyles.Put(aElement, existingData);
-
   // We can only treat this element as a restyle root if we would
   // actually restyle its descendants (so either call
   // ReResolveStyleContext on it or just reframe it).
   if ((aRestyleHint & (eRestyle_Self | eRestyle_Subtree)) ||
       (aMinChangeHint & nsChangeHint_ReconstructFrame)) {
-    for (const Element* cur = aElement; !cur->HasFlag(RootBit()); ) {
+    Element* cur = aElement;
+    while (!cur->HasFlag(RootBit())) {
       nsIContent* parent = cur->GetFlattenedTreeParent();
       // Stop if we have no parent or the parent is not an element or
       // we're part of the viewport scrollbars (because those are not
       // frametree descendants of the primary frame of the root
       // element).
       // XXXbz maybe the primary frame of the root should be the root scrollframe?
       if (!parent || !parent->IsElement() ||
           // If we've hit the root via a native anonymous kid and that
@@ -376,18 +381,26 @@ inline bool RestyleTracker::AddPendingRe
         break;
       }
       cur = parent->AsElement();
     }
     // At this point some ancestor of aElement (possibly aElement
     // itself) is in mRestyleRoots.  Set the root bit on aElement, to
     // speed up searching for an existing root on its descendants.
     aElement->SetFlags(RootBit());
+    if (cur != aElement && !(aRestyleHint & eRestyle_Subtree)) {
+      RestyleData curData;
+      mPendingRestyles.Get(cur, &curData);
+      curData.mDescendants.AppendElement(aElement);
+      mPendingRestyles.Put(cur, curData);
+    }
   }
 
+  mPendingRestyles.Put(aElement, existingData);
+
   mHaveLaterSiblingRestyles =
     mHaveLaterSiblingRestyles || (aRestyleHint & eRestyle_LaterSiblings) != 0;
   return hadRestyleLaterSiblings;
 }
 
 } // namespace mozilla
 
 #endif /* mozilla_RestyleTracker_h */
diff --git a/layout/base/nsChangeHint.h b/layout/base/nsChangeHint.h
--- a/layout/base/nsChangeHint.h
+++ b/layout/base/nsChangeHint.h
@@ -108,20 +108,41 @@ enum nsChangeHint {
    * This change hint has *no* change handling behavior.  However, it
    * exists to be a non-inherited hint, because when the border-style
    * changes, and it's inherited by a child, that might require a reflow
    * due to the border-width change on the child.
    */
   nsChangeHint_BorderStyleNoneChange = 0x8000,
 
   /**
+   * A non-inherited hint reflecting that style data changed which no change
+   * handling behavior.  We need to return this, rather than NS_STYLE_HINT_NONE,
+   * so that certain optimizations that manipulate the style context tree are
+   * correct.
+   *
+   * nsChangeHint_NeutralChange must be returned by CalcDifference on a given
+   * style struct if the data in the style structs are meaningfully different
+   * and if no other change hints are returned.  If any other change hints are
+   * set, then nsChangeHint_NeutralChange need not also be included, but it is
+   * safe to do so.  (An example of style structs having non-meaningfully
+   * different data would be cached information that would be re-calculated
+   * to the same values, such as nsStyleBorder::mSubImages.)
+   */
+  nsChangeHint_NeutralChange = 0x10000,
+
+  /**
+   * An inherited version of nsChangeHint_NeutralChange.
+   */
+  nsChangeHint_InheritedNeutralChange = 0x20000,
+
+  /**
    * SVG textPath needs to be recomputed because the path has changed.
    * This means that the glyph positions of the text need to be recomputed.
    */
-  nsChangeHint_UpdateTextPath = 0x10000
+  nsChangeHint_UpdateTextPath = 0x40000
 
   // IMPORTANT NOTE: When adding new hints, consider whether you need to
   // add them to NS_HintsNotHandledForDescendantsIn() below.
 };
 
 // Redefine these operators to return nothing. This will catch any use
 // of these operators on hints. We should not be using these operators
 // on nsChangeHints
@@ -171,29 +192,31 @@ inline bool NS_IsHintSubset(nsChangeHint
           nsChangeHint_UpdateTransformLayer | \
           nsChangeHint_UpdateEffects | \
           nsChangeHint_UpdateOpacityLayer | \
           nsChangeHint_UpdateOverflow | \
           nsChangeHint_ChildrenOnlyTransform | \
           nsChangeHint_RecomputePosition | \
           nsChangeHint_AddOrRemoveTransform | \
           nsChangeHint_BorderStyleNoneChange | \
+          nsChangeHint_NeutralChange | \
           nsChangeHint_NeedReflow | \
           nsChangeHint_ClearAncestorIntrinsics)
 
 inline nsChangeHint NS_HintsNotHandledForDescendantsIn(nsChangeHint aChangeHint) {
   nsChangeHint result = nsChangeHint(aChangeHint & (
     nsChangeHint_UpdateTransformLayer |
     nsChangeHint_UpdateEffects |
     nsChangeHint_UpdateOpacityLayer |
     nsChangeHint_UpdateOverflow |
     nsChangeHint_ChildrenOnlyTransform |
     nsChangeHint_RecomputePosition |
     nsChangeHint_AddOrRemoveTransform |
-    nsChangeHint_BorderStyleNoneChange));
+    nsChangeHint_BorderStyleNoneChange |
+    nsChangeHint_NeutralChange));
 
   if (!NS_IsHintSubset(nsChangeHint_NeedDirtyReflow, aChangeHint) &&
       NS_IsHintSubset(nsChangeHint_NeedReflow, aChangeHint)) {
     // If NeedDirtyReflow is *not* set, then NeedReflow is a
     // non-inherited hint.
     NS_UpdateHint(result, nsChangeHint_NeedReflow);
   }
 
diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -1122,16 +1122,18 @@ nsPresContext::Init(nsDeviceContext* aDe
                                 this);
 
   nsresult rv = mEventManager->Init();
   NS_ENSURE_SUCCESS(rv, rv);
 
   mEventManager->SetPresContext(this);
 
 #ifdef DEBUG
+  mDebugRestyle = RestyleManager::DebugRestyleInitiallyEnabled();
+
   mInitialized = true;
 #endif
 
   mBorderWidthTable[NS_STYLE_BORDER_WIDTH_THIN] = CSSPixelsToAppUnits(1);
   mBorderWidthTable[NS_STYLE_BORDER_WIDTH_MEDIUM] = CSSPixelsToAppUnits(3);
   mBorderWidthTable[NS_STYLE_BORDER_WIDTH_THICK] = CSSPixelsToAppUnits(5);
 
   return NS_OK;
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -1137,16 +1137,24 @@ public:
 
   /**
    * Checks for MozAfterPaint listeners on the document and 
    * any subdocuments, except for subdocuments that are non-top-level
    * content documents.
    */
   bool MayHavePaintEventListenerInSubDocument();
 
+#ifdef DEBUG
+  // Controls for whether debug information about restyling in this
+  // document should be output.
+  bool DebugRestyle() const { return mDebugRestyle; }
+  void StartRestyleTracing() { mDebugRestyle = true; }
+  void StopRestyleTracing() { mDebugRestyle = false; }
+#endif
+
 protected:
   void InvalidateThebesLayers();
   void AppUnitsPerDevPixelChanged();
 
   void HandleRebuildUserFontSet() {
     mPostedFlushUserFontSet = false;
     FlushUserFontSet();
   }
@@ -1332,16 +1340,19 @@ protected:
   // Should we paint flash in this context? Do not use this variable directly.
   // Use GetPaintFlashing() method instead.
   mutable unsigned mPaintFlashing : 1;
   mutable unsigned mPaintFlashingInitialized : 1;
 
   unsigned mHasWarnedAboutPositionedTableParts : 1;
 
 #ifdef DEBUG
+  // Should we output debug information about restyling for this document?
+  bool                  mDebugRestyle;
+
   bool                  mInitialized;
 #endif
 
 
 protected:
 
   virtual ~nsPresContext() NS_HIDDEN;
 
diff --git a/layout/reftests/bugs/952328-1-ref.html b/layout/reftests/bugs/952328-1-ref.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/952328-1-ref.html
@@ -0,0 +1,5 @@
+<!DOCTYPE html>
+<style>
+.test:visited { color: red; }
+</style>
+<a href="">This text must not be red.</a>
diff --git a/layout/reftests/bugs/952328-1.html b/layout/reftests/bugs/952328-1.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/bugs/952328-1.html
@@ -0,0 +1,12 @@
+<!DOCTYPE html>
+<html class="reftest-wait">
+<style>
+.test:visited { color: red; }
+</style>
+<a class="test" href="">This text must not be red.</a>
+<script>
+window.addEventListener("MozReftestInvalidate", function() {
+  document.querySelector("a").removeAttribute("class");
+  document.documentElement.removeAttribute("class");
+}, false);
+</script>
diff --git a/layout/reftests/bugs/reftest.list b/layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list
+++ b/layout/reftests/bugs/reftest.list
@@ -1789,16 +1789,17 @@ fuzzy-if(OSX==10.6,2,30) skip-if(B2G&&br
 == 936670-1.svg 936670-1-ref.svg
 == 941940-1.html 941940-1-ref.html
 == 942017.html 942017-ref.html
 == 942672-1.html 942672-1-ref.html
 == 953334-win32-clipping.html 953334-win32-clipping-ref.html
 == 956513-1.svg 956513-1-ref.svg
 == 944291-1.html 944291-1-ref.html
 == 950436-1.html 950436-1-ref.html
+== 952328-1.html 952328-1-ref.html
 == 957770-1.svg 957770-1-ref.svg
 == 960277-1.html 960277-1-ref.html
 pref(layout.css.overflow-clip-box.enabled,true) fuzzy(50,10) == 966992-1.html 966992-1-ref.html
 skip-if(Android) == 966510-1.html 966510-1-ref.html # scrollable elements other than the root probably won't work well on android until bug 776030 is fixed
 skip-if(Android) == 966510-2.html 966510-2-ref.html # same as above
 == 978911-1.svg 978911-1-ref.svg
 == 983084-1.html 983084-1-ref.html
 == 983084-2.html 983084-2-ref.html
diff --git a/layout/style/AnimationCommon.cpp b/layout/style/AnimationCommon.cpp
--- a/layout/style/AnimationCommon.cpp
+++ b/layout/style/AnimationCommon.cpp
@@ -253,18 +253,19 @@ CommonAnimationManager::UpdateThrottledS
   } while ((ruleNode = ruleNode->GetParent()));
 
   nsRefPtr<nsStyleContext> newStyle = mPresContext->PresShell()->StyleSet()->
     ResolveStyleForRules(aParentStyle, oldStyle, rules);
 
   // We absolutely must call CalcStyleDifference in order to ensure the
   // new context has all the structs cached that the old context had.
   // We also need it for processing of the changes.
+  bool anyChanges;
   nsChangeHint styleChange =
-    oldStyle->CalcStyleDifference(newStyle, nsChangeHint(0));
+    oldStyle->CalcStyleDifference(newStyle, nsChangeHint(0), anyChanges);
   aChangeList.AppendChange(primaryFrame, primaryFrame->GetContent(),
                            styleChange);
 
   primaryFrame->SetStyleContext(newStyle);
 
   ReparentBeforeAndAfter(aElement, primaryFrame, newStyle,
                          mPresContext->PresShell()->StyleSet());
 
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -1696,21 +1696,23 @@ static bool SelectorMatches(Element* aEl
                               nsCSSSelector* aSelector,
                               NodeMatchContext& aNodeMatchContext,
                               TreeMatchContext& aTreeMatchContext,
                               bool* const aDependence = nullptr)
 
 {
   NS_PRECONDITION(!aSelector->IsPseudoElement(),
                   "Pseudo-element snuck into SelectorMatches?");
+  /*
   NS_ABORT_IF_FALSE(aTreeMatchContext.mForStyling ||
                     !aNodeMatchContext.mIsRelevantLink,
                     "mIsRelevantLink should be set to false when mForStyling "
                     "is false since we don't know how to set it correctly in "
                     "Has(Attribute|State)DependentStyle");
+  */
 
   // namespace/tag match
   // optimization : bail out early if we can
   if ((kNameSpaceID_Unknown != aSelector->mNameSpace &&
        aElement->GetNameSpaceID() != aSelector->mNameSpace))
     return false;
 
   if (aSelector->mLowercaseTag) {
@@ -2677,22 +2679,27 @@ AttributeEnumFunc(nsCSSSelector* aSelect
     return;
   }
 
   nsRestyleHint possibleChange = RestyleHintForOp(aSelector->mOperator);
 
   // If enumData->change already includes all the bits of possibleChange, don't
   // bother calling SelectorMatches, since even if it returns false
   // enumData->change won't change.
-  NodeMatchContext nodeContext(nsEventStates(), false);
+  NodeMatchContext nodeContext(nsEventStates(),
+                               nsCSSRuleProcessor::IsLink(data->mElement));
+  if (nodeContext.mIsRelevantLink) {
+    data->mTreeMatchContext.SetHaveRelevantLink();
+  }
   if ((possibleChange & ~(aData->change)) &&
       SelectorMatches(data->mElement, aSelector, nodeContext,
                       data->mTreeMatchContext) &&
       SelectorMatchesTree(data->mElement, aSelector->mNext,
-                          data->mTreeMatchContext, false)) {
+                          data->mTreeMatchContext,
+                          !nodeContext.mIsRelevantLink)) {
     aData->change = nsRestyleHint(aData->change | possibleChange);
   }
 }
 
 static MOZ_ALWAYS_INLINE void
 EnumerateSelectors(nsTArray<nsCSSSelector*>& aSelectors, AttributeEnumData* aData)
 {
   nsCSSSelector **iter = aSelectors.Elements(),
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -1577,16 +1577,39 @@ nsRuleNode::PropagateDependentBit(nsStyl
     curr->mDependentBits |= bit;
 
     if (curr->IsUsedDirectly()) {
       curr->mStyleData.SetStyleData(aSID, mPresContext, aStruct);
     }
   }
 }
 
+/* static */ void
+nsRuleNode::PropagateGrandancestorBit(nsStyleContext* aContext,
+                                      nsStyleContext* aContextInheritedFrom)
+{
+  MOZ_ASSERT(aContext);
+
+  aContext->AddStyleBit(NS_STYLE_USES_GRANDANCESTOR_STYLE);
+
+  nsStyleContext* context = aContext->GetParent();
+  if (!context) {
+    return;
+  }
+
+  for (;;) {
+    nsStyleContext* parent = context->GetParent();
+    if (!parent || parent == aContextInheritedFrom) {
+      break;
+    }
+    context->AddStyleBit(NS_STYLE_USES_GRANDANCESTOR_STYLE);
+    context = parent;
+  }
+}
+
 /*
  * The following "Check" functions are used for determining what type of
  * sharing can be used for the data on this rule node.  MORE HERE...
  */
 
 /*
  * a callback function that that can revise the result of
  * CheckSpecifiedProperties before finishing; aResult is the current
@@ -2255,16 +2278,17 @@ nsRuleNode::WalkRuleTree(const nsStyleSt
     nsStyleContext* parentContext = aContext->GetParent();
     if (isReset) {
       /* Reset structs don't inherit from first-line. */
       /* See similar code in COMPUTE_START_RESET */
       while (parentContext &&
              parentContext->GetPseudo() == nsCSSPseudoElements::firstLine) {
         parentContext = parentContext->GetParent();
       }
+      PropagateGrandancestorBit(aContext, parentContext);
     }
     if (parentContext) {
       // We have a parent, and so we should just inherit from the parent.
       // Set the inherit bits on our context.  These bits tell the style context that
       // it never has to go back to the rule tree for data.  Instead the style context tree
       // should be walked to find the data.
       const void* parentStruct = parentContext->StyleData(aSID);
       aContext->AddStyleBit(bit); // makes const_cast OK.
@@ -2621,18 +2645,20 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
   }                                                                           \
   bool canStoreInRuleTree = aCanStoreInRuleTree;
 
 /**
  * End an nsRuleNode::Compute*Data function for an inherited struct.
  *
  * @param type_ The nsStyle* type this function computes.
  * @param data_ Variable holding the result of this function.
+ * @param parentdata_ Variable holding the parent style context's data for
+ *                    this struct.
  */
-#define COMPUTE_END_INHERITED(type_, data_)                                   \
+#define COMPUTE_END_INHERITED(type_, data_, parentdata_)                      \
   NS_POSTCONDITION(!canStoreInRuleTree || aRuleDetail == eRuleFullReset ||    \
                    (aStartStruct && aRuleDetail == eRulePartialReset),        \
                    "canStoreInRuleTree must be false for inherited structs "  \
                    "unless all properties have been specified with values "   \
                    "other than inherit");                                     \
   if (canStoreInRuleTree) {                                                   \
     /* We were fully specified and can therefore be cached right on the */    \
     /* rule node. */                                                          \
@@ -2649,25 +2675,37 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
     PropagateDependentBit(eStyleStruct_##type_, aHighestNode, data_);         \
     /* Tell the style context that it doesn't own the data */                 \
     aContext->                                                                \
       AddStyleBit(nsCachedStyleData::GetBitForSID(eStyleStruct_##type_));     \
   }                                                                           \
   /* Always cache inherited data on the style context */                      \
   aContext->SetStyle##type_(data_);                                           \
                                                                               \
+  /* Record whether the data references style context allocated objects */    \
+  /* from an ancestor style context, and thus cannot handle a no-op     */    \
+  /* restyling by simply updating the style context's parent point.     */    \
+  if (!aContext->SharesStyleContextAllocatedObjectsWithParent() &&            \
+      data_ != parentdata_ &&                                                 \
+      data_->SharesStyleContextAllocatedObjectsWith(*parentdata_)) {          \
+    printf("(inherited) setting NS_STYLE_SHARES_SC_ALLOCATED_OBJECT_WITH_PARENT\n"); \
+    aContext->AddStyleBit(NS_STYLE_SHARES_SC_ALLOCATED_OBJECT_WITH_PARENT);   \
+  }                                                                           \
+                                                                              \
   return data_;
 
 /**
  * End an nsRuleNode::Compute*Data function for a reset struct.
  *
  * @param type_ The nsStyle* type this function computes.
  * @param data_ Variable holding the result of this function.
+ * @param parentdata_ Variable holding the parent style context's data for
+ *                    this struct.
  */
-#define COMPUTE_END_RESET(type_, data_)                                       \
+#define COMPUTE_END_RESET(type_, data_, parentdata_)                          \
   NS_POSTCONDITION(!canStoreInRuleTree ||                                     \
                    aRuleDetail == eRuleNone ||                                \
                    aRuleDetail == eRulePartialReset ||                        \
                    aRuleDetail == eRuleFullReset,                             \
                    "canStoreInRuleTree must be false for reset structs "      \
                    "if any properties were specified as inherit");            \
   if (!canStoreInRuleTree)                                                    \
     /* We can't be cached in the rule node.  We have to be put right */       \
@@ -2684,16 +2722,26 @@ nsRuleNode::AdjustLogicalBoxProp(nsStyle
                    mStyleStructs[eStyleStruct_##type_],                       \
                  "Going to leak style data");                                 \
     aHighestNode->mStyleData.mResetData->                                     \
       mStyleStructs[eStyleStruct_##type_] = data_;                            \
     /* Propagate the bit down. */                                             \
     PropagateDependentBit(eStyleStruct_##type_, aHighestNode, data_);         \
   }                                                                           \
                                                                               \
+  /* Record whether the data references style context allocated objects */    \
+  /* from an ancestor style context, and thus cannot handle a no-op     */    \
+  /* restyling by simply updating the style context's parent point.     */    \
+  if (!aContext->SharesStyleContextAllocatedObjectsWithParent() &&            \
+      data_ != parentdata_ &&                                                 \
+      data_->SharesStyleContextAllocatedObjectsWith(*parentdata_)) {          \
+    printf("(reset) setting NS_STYLE_SHARES_SC_ALLOCATED_OBJECT_WITH_PARENT\n"); \
+    aContext->AddStyleBit(NS_STYLE_SHARES_SC_ALLOCATED_OBJECT_WITH_PARENT);   \
+  }                                                                           \
+                                                                              \
   return data_;
 
 // This function figures out how much scaling should be suppressed to
 // satisfy scriptminsize. This is our attempt to implement
 // http://www.w3.org/TR/MathML2/chapter3.html#id.3.3.4.2.2
 // This is called after mScriptLevel, mScriptMinSize and mScriptSizeMultiplier
 // have been set in aFont.
 //
@@ -3842,16 +3890,18 @@ nsRuleNode::SetGenericFont(nsPresContext
     ResolveVariableReferences(eStyleStruct_Font, &ruleData, aContext);
 
     nsRuleNode::SetFont(aPresContext, context,
                         aGenericFontID, &ruleData, &parentFont, aFont,
                         false, dummy);
 
     parentFont = *aFont;
   }
+
+  PropagateGrandancestorBit(aContext, higherContext);
 }
 
 static bool ExtractGeneric(const nsString& aFamily, bool aGeneric,
                              void *aData)
 {
   nsAutoString *data = static_cast<nsAutoString*>(aData);
 
   if (aGeneric) {
@@ -3938,17 +3988,17 @@ nsRuleNode::ComputeFontData(void* aStart
   }
   else {
     // re-calculate the font as a generic font
     canStoreInRuleTree = false;
     nsRuleNode::SetGenericFont(mPresContext, aContext, generic,
                                font);
   }
 
-  COMPUTE_END_INHERITED(Font, font)
+  COMPUTE_END_INHERITED(Font, font, parentFont)
 }
 
 template <typename T>
 inline uint32_t ListLength(const T* aList)
 {
   uint32_t len = 0;
   while (aList) {
     len++;
@@ -4264,17 +4314,17 @@ nsRuleNode::ComputeTextData(void* aStart
   // text-combine-horizontal: enum, inherit, initial
   SetDiscrete(*aRuleData->ValueForTextCombineHorizontal(),
               text->mTextCombineHorizontal,
               canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_UNSET_INHERIT,
               parentText->mTextCombineHorizontal,
               NS_STYLE_TEXT_COMBINE_HORIZ_NONE, 0, 0, 0, 0);
 
-  COMPUTE_END_INHERITED(Text, text)
+  COMPUTE_END_INHERITED(Text, text, parentText)
 }
 
 const void*
 nsRuleNode::ComputeTextResetData(void* aStartStruct,
                                  const nsRuleData* aRuleData,
                                  nsStyleContext* aContext,
                                  nsRuleNode* aHighestNode,
                                  const RuleDetail aRuleDetail,
@@ -4426,17 +4476,17 @@ nsRuleNode::ComputeTextResetData(void* a
   }
 
   // unicode-bidi: enum, inherit, initial
   SetDiscrete(*aRuleData->ValueForUnicodeBidi(), text->mUnicodeBidi, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_UNSET_INITIAL,
               parentText->mUnicodeBidi,
               NS_STYLE_UNICODE_BIDI_NORMAL, 0, 0, 0, 0);
 
-  COMPUTE_END_RESET(TextReset, text)
+  COMPUTE_END_RESET(TextReset, text, parentText)
 }
 
 const void*
 nsRuleNode::ComputeUserInterfaceData(void* aStartStruct,
                                      const nsRuleData* aRuleData,
                                      nsStyleContext* aContext,
                                      nsRuleNode* aHighestNode,
                                      const RuleDetail aRuleDetail,
@@ -4523,17 +4573,17 @@ nsRuleNode::ComputeUserInterfaceData(voi
 
   // user-focus: enum, inherit, initial
   SetDiscrete(*aRuleData->ValueForUserFocus(),
               ui->mUserFocus, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_UNSET_INHERIT,
               parentUI->mUserFocus,
               NS_STYLE_USER_FOCUS_NONE, 0, 0, 0, 0);
 
-  COMPUTE_END_INHERITED(UserInterface, ui)
+  COMPUTE_END_INHERITED(UserInterface, ui, parentUI)
 }
 
 const void*
 nsRuleNode::ComputeUIResetData(void* aStartStruct,
                                const nsRuleData* aRuleData,
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
@@ -4565,17 +4615,17 @@ nsRuleNode::ComputeUIResetData(void* aSt
 
   // -moz-window-shadow: enum, inherit, initial
   SetDiscrete(*aRuleData->ValueForWindowShadow(),
               ui->mWindowShadow, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_UNSET_INITIAL,
               parentUI->mWindowShadow,
               NS_STYLE_WINDOW_SHADOW_DEFAULT, 0, 0, 0, 0);
 
-  COMPUTE_END_RESET(UIReset, ui)
+  COMPUTE_END_RESET(UIReset, ui, parentUI)
 }
 
 // Information about each transition or animation property that is
 // constant.
 struct TransitionPropInfo {
   nsCSSProperty property;
   // Location of the count of the property's computed value.
   uint32_t nsStyleDisplay::* sdCount;
@@ -5627,17 +5677,17 @@ nsRuleNode::ComputeDisplayData(void* aSt
 
   // orient: enum, inherit, initial
   SetDiscrete(*aRuleData->ValueForOrient(),
               display->mOrient, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_UNSET_INITIAL,
               parentDisplay->mOrient,
               NS_STYLE_ORIENT_AUTO, 0, 0, 0, 0);
 
-  COMPUTE_END_RESET(Display, display)
+  COMPUTE_END_RESET(Display, display, parentDisplay)
 }
 
 const void*
 nsRuleNode::ComputeVisibilityData(void* aStartStruct,
                                   const nsRuleData* aRuleData,
                                   nsStyleContext* aContext,
                                   nsRuleNode* aHighestNode,
                                   const RuleDetail aRuleDetail,
@@ -5714,17 +5764,17 @@ nsRuleNode::ComputeVisibilityData(void* 
         break;
       default:
         NS_NOTREACHED("Invalid image-orientation enumerated value");
     }
   } else {
     MOZ_ASSERT(orientation->GetUnit() == eCSSUnit_Null, "Should be null unit");
   }
 
-  COMPUTE_END_INHERITED(Visibility, visibility)
+  COMPUTE_END_INHERITED(Visibility, visibility, parentVisibility)
 }
 
 const void*
 nsRuleNode::ComputeColorData(void* aStartStruct,
                              const nsRuleData* aRuleData,
                              nsStyleContext* aContext,
                              nsRuleNode* aHighestNode,
                              const RuleDetail aRuleDetail,
@@ -5745,17 +5795,17 @@ nsRuleNode::ComputeColorData(void* aStar
   else if (colorValue->GetUnit() == eCSSUnit_Initial) {
     color->mColor = mPresContext->DefaultColor();
   }
   else {
     SetColor(*colorValue, parentColor->mColor, mPresContext, aContext,
              color->mColor, canStoreInRuleTree);
   }
 
-  COMPUTE_END_INHERITED(Color, color)
+  COMPUTE_END_INHERITED(Color, color, parentColor)
 }
 
 // information about how to compute values for background-* properties
 template <class SpecifiedValueItem, class ComputedValueItem>
 struct BackgroundItemComputer {
 };
 
 template <>
@@ -6306,17 +6356,17 @@ nsRuleNode::ComputeBackgroundData(void* 
     FillBackgroundList(bg->mLayers, &nsStyleBackground::Layer::mSize,
                        bg->mSizeCount, fillCount);
   }
 
   // Now that the dust has settled, register the images with the document
   for (uint32_t i = 0; i < bg->mImageCount; ++i)
     bg->mLayers[i].TrackImages(aContext->PresContext());
 
-  COMPUTE_END_RESET(Background, bg)
+  COMPUTE_END_RESET(Background, bg, parentBG)
 }
 
 const void*
 nsRuleNode::ComputeMarginData(void* aStartStruct,
                               const nsRuleData* aRuleData,
                               nsStyleContext* aContext,
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
@@ -6350,17 +6400,17 @@ nsRuleNode::ComputeMarginData(void* aSta
                  SETCOORD_LPAH | SETCOORD_INITIAL_ZERO | SETCOORD_STORE_CALC |
                    SETCOORD_UNSET_INITIAL,
                  aContext, mPresContext, canStoreInRuleTree)) {
       margin->mMargin.Set(side, coord);
     }
   }
 
   margin->RecalcData();
-  COMPUTE_END_RESET(Margin, margin)
+  COMPUTE_END_RESET(Margin, margin, parentMargin)
 }
 
 static void
 SetBorderImageRect(const nsCSSValue& aValue,
                    /** outparam */ nsCSSRect& aRect)
 {
   switch (aValue.GetUnit()) {
   case eCSSUnit_Null:
@@ -6810,17 +6860,17 @@ nsRuleNode::ComputeBorderData(void* aSta
               border->mBorderImageRepeatV,
               canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_UNSET_INITIAL,
               parentBorder->mBorderImageRepeatV,
               NS_STYLE_BORDER_IMAGE_REPEAT_STRETCH, 0, 0, 0, 0);
 
   border->TrackImage(aContext->PresContext());
 
-  COMPUTE_END_RESET(Border, border)
+  COMPUTE_END_RESET(Border, border, parentBorder)
 }
 
 const void*
 nsRuleNode::ComputePaddingData(void* aStartStruct,
                                const nsRuleData* aRuleData,
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
@@ -6854,17 +6904,17 @@ nsRuleNode::ComputePaddingData(void* aSt
                  SETCOORD_LPH | SETCOORD_INITIAL_ZERO | SETCOORD_STORE_CALC |
                    SETCOORD_UNSET_INITIAL,
                  aContext, mPresContext, canStoreInRuleTree)) {
       padding->mPadding.Set(side, coord);
     }
   }
 
   padding->RecalcData();
-  COMPUTE_END_RESET(Padding, padding)
+  COMPUTE_END_RESET(Padding, padding, parentPadding)
 }
 
 const void*
 nsRuleNode::ComputeOutlineData(void* aStartStruct,
                                const nsRuleData* aRuleData,
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
@@ -6965,17 +7015,17 @@ nsRuleNode::ComputeOutlineData(void* aSt
              eCSSUnit_Unset == unit) {
     outline->SetOutlineStyle(NS_STYLE_BORDER_STYLE_NONE);
   } else if (eCSSUnit_Inherit == unit) {
     canStoreInRuleTree = false;
     outline->SetOutlineStyle(parentOutline->GetOutlineStyle());
   }
 
   outline->RecalcData(mPresContext);
-  COMPUTE_END_RESET(Outline, outline)
+  COMPUTE_END_RESET(Outline, outline, parentOutline)
 }
 
 const void*
 nsRuleNode::ComputeListData(void* aStartStruct,
                             const nsRuleData* aRuleData,
                             nsStyleContext* aContext,
                             nsRuleNode* aHighestNode,
                             const RuleDetail aRuleDetail,
@@ -7063,17 +7113,17 @@ nsRuleNode::ComputeListData(void* aStart
                    canStoreInRuleTree) - list->mImageRegion.x;
     break;
   }
 
   default:
     NS_ABORT_IF_FALSE(false, "unrecognized image-region unit");
   }
 
-  COMPUTE_END_INHERITED(List, list)
+  COMPUTE_END_INHERITED(List, list, parentList)
 }
 
 static void
 SetGridTrackBreadth(const nsCSSValue& aValue,
                     nsStyleCoord& aResult,
                     nsStyleContext* aStyleContext,
                     nsPresContext* aPresContext,
                     bool& aCanStoreInRuleTree)
@@ -7406,16 +7456,17 @@ nsRuleNode::ComputePositionData(void* aS
           // "align-self: auto" computes to the default "align-items" value:
           inheritedAlignSelf = NS_STYLE_ALIGN_ITEMS_INITIAL_VALUE;
         } else {
           // Normal case -- we have a grandparent.
           // Its "align-items" value is what we should end up inheriting.
           const nsStylePosition* grandparentPos =
             grandparentContext->StylePosition();
           inheritedAlignSelf = grandparentPos->mAlignItems;
+          aContext->AddStyleBit(NS_STYLE_USES_GRANDANCESTOR_STYLE);
         }
       }
     }
 
     pos->mAlignSelf = inheritedAlignSelf;
     canStoreInRuleTree = false;
   } else {
     SetDiscrete(*aRuleData->ValueForAlignSelf(),
@@ -7582,17 +7633,17 @@ nsRuleNode::ComputePositionData(void* aS
                  aContext, nullptr, canStoreInRuleTree)) {
     if (eCSSUnit_Inherit == zIndexValue->GetUnit()) {
       // handle inherit, because it's ok to inherit 'auto' here
       canStoreInRuleTree = false;
       pos->mZIndex = parentPos->mZIndex;
     }
   }
 
-  COMPUTE_END_RESET(Position, pos)
+  COMPUTE_END_RESET(Position, pos, parentPos)
 }
 
 const void*
 nsRuleNode::ComputeTableData(void* aStartStruct,
                              const nsRuleData* aRuleData,
                              nsStyleContext* aContext,
                              nsRuleNode* aHighestNode,
                              const RuleDetail aRuleDetail,
@@ -7608,17 +7659,17 @@ nsRuleNode::ComputeTableData(void* aStar
               NS_STYLE_TABLE_LAYOUT_AUTO, 0, 0, 0, 0);
 
   // span: pixels (not a real CSS prop)
   const nsCSSValue* spanValue = aRuleData->ValueForSpan();
   if (eCSSUnit_Enumerated == spanValue->GetUnit() ||
       eCSSUnit_Integer == spanValue->GetUnit())
     table->mSpan = spanValue->GetIntValue();
 
-  COMPUTE_END_RESET(Table, table)
+  COMPUTE_END_RESET(Table, table, parentTable)
 }
 
 const void*
 nsRuleNode::ComputeTableBorderData(void* aStartStruct,
                                    const nsRuleData* aRuleData,
                                    nsStyleContext* aContext,
                                    nsRuleNode* aHighestNode,
                                    const RuleDetail aRuleDetail,
@@ -7668,17 +7719,17 @@ nsRuleNode::ComputeTableBorderData(void*
               table->mEmptyCells, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_UNSET_INHERIT,
               parentTable->mEmptyCells,
               (mPresContext->CompatibilityMode() == eCompatibility_NavQuirks)
               ? NS_STYLE_TABLE_EMPTY_CELLS_SHOW_BACKGROUND
               : NS_STYLE_TABLE_EMPTY_CELLS_SHOW,
               0, 0, 0, 0);
 
-  COMPUTE_END_INHERITED(TableBorder, table)
+  COMPUTE_END_INHERITED(TableBorder, table, parentTable)
 }
 
 const void*
 nsRuleNode::ComputeContentData(void* aStartStruct,
                                const nsRuleData* aRuleData,
                                nsStyleContext* aContext,
                                nsRuleNode* aHighestNode,
                                const RuleDetail aRuleDetail,
@@ -7911,17 +7962,17 @@ nsRuleNode::ComputeContentData(void* aSt
   // If we ended up with an image, track it.
   for (uint32_t i = 0; i < content->ContentCount(); ++i) {
     if ((content->ContentAt(i).mType == eStyleContentType_Image) &&
         content->ContentAt(i).mContent.mImage) {
       content->ContentAt(i).TrackImage(aContext->PresContext());
     }
   }
 
-  COMPUTE_END_RESET(Content, content)
+  COMPUTE_END_RESET(Content, content, parentContent)
 }
 
 const void*
 nsRuleNode::ComputeQuotesData(void* aStartStruct,
                               const nsRuleData* aRuleData,
                               nsStyleContext* aContext,
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
@@ -7966,17 +8017,17 @@ nsRuleNode::ComputeQuotesData(void* aSta
       ourQuotes = ourQuotes->mNext;
     }
     break;
   }
   default:
     NS_ABORT_IF_FALSE(false, "unexpected value unit");
   }
 
-  COMPUTE_END_INHERITED(Quotes, quotes)
+  COMPUTE_END_INHERITED(Quotes, quotes, parentQuotes)
 }
 
 const void*
 nsRuleNode::ComputeXULData(void* aStartStruct,
                            const nsRuleData* aRuleData,
                            nsStyleContext* aContext,
                            nsRuleNode* aHighestNode,
                            const RuleDetail aRuleDetail,
@@ -8032,17 +8083,17 @@ nsRuleNode::ComputeXULData(void* aStartS
   } else if (eCSSUnit_Initial == stackSizingValue->GetUnit() ||
              eCSSUnit_Unset == stackSizingValue->GetUnit()) {
     xul->mStretchStack = true;
   } else if (eCSSUnit_Enumerated == stackSizingValue->GetUnit()) {
     xul->mStretchStack = stackSizingValue->GetIntValue() ==
       NS_STYLE_STACK_SIZING_STRETCH_TO_FIT;
   }
 
-  COMPUTE_END_RESET(XUL, xul)
+  COMPUTE_END_RESET(XUL, xul, parentXUL)
 }
 
 const void*
 nsRuleNode::ComputeColumnData(void* aStartStruct,
                               const nsRuleData* aRuleData,
                               nsStyleContext* aContext,
                               nsRuleNode* aHighestNode,
                               const RuleDetail aRuleDetail,
@@ -8164,17 +8215,17 @@ nsRuleNode::ComputeColumnData(void* aSta
   // column-fill: enum
   SetDiscrete(*aRuleData->ValueForColumnFill(),
                 column->mColumnFill, canStoreInRuleTree,
                 SETDSC_ENUMERATED | SETDSC_UNSET_INITIAL,
                 parent->mColumnFill,
                 NS_STYLE_COLUMN_FILL_BALANCE,
                 0, 0, 0, 0);
 
-  COMPUTE_END_RESET(Column, column)
+  COMPUTE_END_RESET(Column, column, parent)
 }
 
 static void
 SetSVGPaint(const nsCSSValue& aValue, const nsStyleSVGPaint& parentPaint,
             nsPresContext* aPresContext, nsStyleContext *aContext,
             nsStyleSVGPaint& aResult, nsStyleSVGPaintType aInitialPaintType,
             bool& aCanStoreInRuleTree)
 {
@@ -8554,17 +8605,17 @@ nsRuleNode::ComputeSVGData(void* aStartS
 
   // text-rendering: enum, inherit, initial
   SetDiscrete(*aRuleData->ValueForTextRendering(),
               svg->mTextRendering, canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_UNSET_INHERIT,
               parentSVG->mTextRendering,
               NS_STYLE_TEXT_RENDERING_AUTO, 0, 0, 0, 0);
 
-  COMPUTE_END_INHERITED(SVG, svg)
+  COMPUTE_END_INHERITED(SVG, svg, parentSVG)
 }
 
 // Returns true if the nsStyleFilter was successfully set using the nsCSSValue.
 bool
 nsRuleNode::SetStyleFilterToCSSValue(nsStyleFilter* aStyleFilter,
                                      const nsCSSValue& aValue,
                                      nsStyleContext* aStyleContext,
                                      nsPresContext* aPresContext,
@@ -8757,17 +8808,17 @@ nsRuleNode::ComputeSVGResetData(void* aS
   // mask-type: enum, inherit, initial
   SetDiscrete(*aRuleData->ValueForMaskType(),
               svgReset->mMaskType,
               canStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_UNSET_INITIAL,
               parentSVGReset->mMaskType,
               NS_STYLE_MASK_TYPE_LUMINANCE, 0, 0, 0, 0);
 
-  COMPUTE_END_RESET(SVGReset, svgReset)
+  COMPUTE_END_RESET(SVGReset, svgReset, parentSVGReset)
 }
 
 const void*
 nsRuleNode::ComputeVariablesData(void* aStartStruct,
                                  const nsRuleData* aRuleData,
                                  nsStyleContext* aContext,
                                  nsRuleNode* aHighestNode,
                                  const RuleDetail aRuleDetail,
@@ -8779,17 +8830,17 @@ nsRuleNode::ComputeVariablesData(void* a
              "shouldn't be in ComputeVariablesData if there were no variable "
              "declarations specified");
 
   CSSVariableResolver resolver(&variables->mVariables);
   resolver.Resolve(&parentVariables->mVariables,
                    aRuleData->mVariables);
   canStoreInRuleTree = false;
 
-  COMPUTE_END_INHERITED(Variables, variables)
+  COMPUTE_END_INHERITED(Variables, variables, parentVariables)
 }
 
 const void*
 nsRuleNode::GetStyleData(nsStyleStructID aSID,
                          nsStyleContext* aContext,
                          bool aComputeData)
 {
   NS_ASSERTION(IsUsedDirectly(),
@@ -9165,8 +9216,52 @@ nsRuleNode::ComputeColor(const nsCSSValu
              "aValue shouldn't have eCSSUnit_Unset");
 
   bool canStoreInRuleTree;
   bool ok = SetColor(aValue, NS_RGB(0, 0, 0), aPresContext, aStyleContext,
                      aResult, canStoreInRuleTree);
   MOZ_ASSERT(ok || !(aPresContext && aStyleContext));
   return ok;
 }
+
+#ifdef DEBUG
+void
+nsRuleNode::DumpRuleTreeStructs()
+{
+  nsRuleNode* rn = this;
+  while (!rn->IsRoot()) {
+    rn = rn->GetParent();
+  }
+  ListWithStructs(stdout, 0);
+}
+
+struct ListData {
+  FILE* out;
+  int32_t indent;
+};
+
+static PLDHashOperator
+ListChildren(PLDHashTable* table, PLDHashEntryHdr* hdr,
+             uint32_t number, void* arg)
+{
+  ChildrenHashEntry *entry = static_cast<ChildrenHashEntry*>(hdr);
+  ListData* data = (ListData*) arg;
+  entry->mRuleNode->ListWithStructs(data->out, data->indent);
+  return PL_DHASH_NEXT;
+}
+
+void
+nsRuleNode::ListWithStructs(FILE* out, int32_t aIndent)
+{
+  for (int32_t i = 0; i < aIndent; i++) {
+    fprintf(out, "  ");
+  }
+  fprintf(out, "%p parent=%p Color=%p\n", this, GetParent(), mStyleData.GetStyleData(eStyleStruct_Color));
+  if (ChildrenAreHashed()) {
+    ListData data = { out, aIndent + 1 };
+    PL_DHashTableEnumerate(ChildrenHash(), ListChildren, &data);
+  } else {
+    for (nsRuleNode* rn = ChildrenList(); rn; rn = rn->mNextSibling) {
+      rn->ListWithStructs(out, aIndent + 1);
+    }
+  }
+}
+#endif
diff --git a/layout/style/nsRuleNode.h b/layout/style/nsRuleNode.h
--- a/layout/style/nsRuleNode.h
+++ b/layout/style/nsRuleNode.h
@@ -22,39 +22,76 @@ class nsIStyleRule;
 struct nsCSSValueList;
 
 class nsCSSValue;
 struct nsCSSRect;
 
 class nsStyleCoord;
 struct nsCSSValuePairList;
 
-template <nsStyleStructID MinIndex, nsStyleStructID Count>
+/*template <nsStyleStructID MinIndex, nsStyleStructID Count>
 class FixedStyleStructArray
 {
 private:
   void* mArray[Count];
 public:
   void*& operator[](nsStyleStructID aIndex) {
     NS_ABORT_IF_FALSE(MinIndex <= aIndex && aIndex < (MinIndex + Count),
                       "out of range");
     return mArray[aIndex - MinIndex];
   }
 
   const void* operator[](nsStyleStructID aIndex) const {
     NS_ABORT_IF_FALSE(MinIndex <= aIndex && aIndex < (MinIndex + Count),
                       "out of range");
     return mArray[aIndex - MinIndex];
   }
+};*/
+
+class InheritedStyleStructArray
+{
+private:
+  void* mArray[nsStyleStructID_Inherited_Count];
+public:
+  void*& operator[](nsStyleStructID aIndex) {
+    NS_ABORT_IF_FALSE(nsStyleStructID_Inherited_Start <= aIndex && aIndex < (nsStyleStructID_Inherited_Start + nsStyleStructID_Inherited_Count),
+                      "out of range");
+    return mArray[aIndex - nsStyleStructID_Inherited_Start];
+  }
+
+  const void* operator[](nsStyleStructID aIndex) const {
+    NS_ABORT_IF_FALSE(nsStyleStructID_Inherited_Start <= aIndex && aIndex < (nsStyleStructID_Inherited_Start + nsStyleStructID_Inherited_Count),
+                      "out of range");
+    return mArray[aIndex - nsStyleStructID_Inherited_Start];
+  }
+};
+
+class ResetStyleStructArray
+{
+private:
+  void* mArray[nsStyleStructID_Reset_Count];
+public:
+  void*& operator[](nsStyleStructID aIndex) {
+    NS_ABORT_IF_FALSE(nsStyleStructID_Reset_Start <= aIndex && aIndex < (nsStyleStructID_Reset_Start + nsStyleStructID_Reset_Count),
+                      "out of range");
+    return mArray[aIndex - nsStyleStructID_Reset_Start];
+  }
+
+  const void* operator[](nsStyleStructID aIndex) const {
+    NS_ABORT_IF_FALSE(nsStyleStructID_Reset_Start <= aIndex && aIndex < (nsStyleStructID_Reset_Start + nsStyleStructID_Reset_Count),
+                      "out of range");
+    return mArray[aIndex - nsStyleStructID_Reset_Start];
+  }
 };
 
 struct nsInheritedStyleData
 {
-  FixedStyleStructArray<nsStyleStructID_Inherited_Start,
-                        nsStyleStructID_Inherited_Count> mStyleStructs;
+//   FixedStyleStructArray<nsStyleStructID_Inherited_Start,
+//                         nsStyleStructID_Inherited_Count> mStyleStructs;
+  InheritedStyleStructArray mStyleStructs;
 
   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
     return aContext->AllocateFromShell(sz);
   }
 
   void DestroyStructs(uint64_t aBits, nsPresContext* aContext) {
 #define STYLE_STRUCT_INHERITED(name, checkdata_cb) \
     void *name##Data = mStyleStructs[eStyleStruct_##name]; \
@@ -79,18 +116,19 @@ struct nsInheritedStyleData
          i = nsStyleStructID(i + 1)) {
       mStyleStructs[i] = nullptr;
     }
   }
 };
 
 struct nsResetStyleData
 {
-  FixedStyleStructArray<nsStyleStructID_Reset_Start,
-                        nsStyleStructID_Reset_Count> mStyleStructs;
+//   ResetStyleStructArray<nsStyleStructID_Reset_Start,
+//                         nsStyleStructID_Reset_Count> mStyleStructs;
+  ResetStyleStructArray mStyleStructs;
 
   nsResetStyleData()
   {
     for (nsStyleStructID i = nsStyleStructID_Reset_Start;
          i < nsStyleStructID_Reset_Start + nsStyleStructID_Reset_Count;
          i = nsStyleStructID(i + 1)) {
       mStyleStructs[i] = nullptr;
     }
@@ -257,16 +295,21 @@ public:
     eRuleFullReset, // All props have been specified.  None has an
                     // "inherit" value.
     eRuleFullMixed, // All props have been specified.  At least one has
                     // a non-"inherit" value.
     eRuleFullInherited  // All props have been specified with "inherit"
                         // values.
   };
 
+#ifdef DEBUG
+  void DumpRuleTreeStructs();
+  void ListWithStructs(FILE* out, int32_t aIndent);
+#endif
+
 private:
   nsPresContext* const mPresContext; // Our pres context.
 
   nsRuleNode* const mParent; // A pointer to the parent node in the tree.
                              // This enables us to walk backwards from the
                              // most specific rule matched to the least
                              // specific rule (which is the optimal order to
                              // use for lookups of style properties.
@@ -414,16 +457,18 @@ public:
   // Implemented in nsStyleSet.h, since it needs to know about nsStyleSet.
   inline void Release();
 
 protected:
   void DestroyInternal(nsRuleNode ***aDestroyQueueTail);
   void PropagateDependentBit(nsStyleStructID aSID, nsRuleNode* aHighestNode,
                              void* aStruct);
   void PropagateNoneBit(uint32_t aBit, nsRuleNode* aHighestNode);
+  static void PropagateGrandancestorBit(nsStyleContext* aContext,
+                                        nsStyleContext* aContextInheritedFrom);
 
   const void* SetDefaultOnRoot(const nsStyleStructID aSID,
                                nsStyleContext* aContext);
 
   /**
    * Resolves any property values in aRuleData for a given style struct that
    * have eCSSUnit_TokenStream values, by resolving them against the computed
    * variable values on the style context and re-parsing the property.
diff --git a/layout/style/nsStyleContext.cpp b/layout/style/nsStyleContext.cpp
--- a/layout/style/nsStyleContext.cpp
+++ b/layout/style/nsStyleContext.cpp
@@ -17,16 +17,18 @@
 #include "nsStyleSet.h"
 #include "nsIPresShell.h"
 
 #include "nsRuleNode.h"
 #include "nsStyleContext.h"
 #include "nsStyleAnimation.h"
 #include "GeckoProfiler.h"
 
+#include <algorithm>
+
 #ifdef DEBUG
 // #define NOISY_DEBUG
 #endif
 
 using namespace mozilla;
 
 //----------------------------------------------------------------------
 
@@ -41,16 +43,17 @@ nsStyleContext::nsStyleContext(nsStyleCo
     mEmptyChild(nullptr),
     mPseudoTag(aPseudoTag),
     mRuleNode(aRuleNode),
     mAllocations(nullptr),
     mCachedResetData(nullptr),
     mBits(((uint64_t)aPseudoType) << NS_STYLE_CONTEXT_TYPE_SHIFT),
     mRefCnt(0)
 {
+  // printf(" nsStyleContext %p\n", this);
   // This check has to be done "backward", because if it were written the
   // more natural way it wouldn't fail even when it needed to.
   static_assert((UINT64_MAX >> NS_STYLE_CONTEXT_TYPE_SHIFT) >=
                 nsCSSPseudoElements::ePseudo_MAX,
                 "pseudo element bits no longer fit in a uint64_t");
   MOZ_ASSERT(aRuleNode);
 
   mNextSibling = this;
@@ -76,20 +79,31 @@ nsStyleContext::nsStyleContext(nsStyleCo
   #define eStyleStruct_LastItem (nsStyleStructID_Length - 1)
   NS_ASSERTION(NS_STYLE_INHERIT_MASK & NS_STYLE_INHERIT_BIT(LastItem),
                "NS_STYLE_INHERIT_MASK must be bigger, and other bits shifted");
   #undef eStyleStruct_LastItem
 }
 
 nsStyleContext::~nsStyleContext()
 {
+  // printf("~nsStyleContext %p\n", this);
   NS_ASSERTION((nullptr == mChild) && (nullptr == mEmptyChild), "destructing context with children");
 
   nsPresContext *presContext = mRuleNode->PresContext();
 
+// #ifdef DEBUG
+//   // Assert that the style structs we are about to destroy are not referenced
+//   // anywhere else in the style context tree.
+//   nsStyleContext* root = this;
+//   while (root->mParent) {
+//     root = root->mParent;
+//   }
+//   root->AssertStructsNotUsedElsewhere(this);
+// #endif
+
   mRuleNode->Release();
 
   presContext->PresShell()->StyleSet()->
     NotifyStyleContextDestroyed(presContext, this);
 
   if (mParent) {
     mParent->RemoveChild(this);
     mParent->Release();
@@ -99,16 +113,83 @@ nsStyleContext::~nsStyleContext()
   mCachedInheritedData.DestroyStructs(mBits, presContext);
   if (mCachedResetData) {
     mCachedResetData->Destroy(mBits, presContext);
   }
 
   FreeAllocations(presContext);
 }
 
+#ifdef DEBUG
+void
+nsStyleContext::AssertStructsNotUsedElsewhere(nsStyleContext* aDestroyingContext) const
+{
+  if (this != aDestroyingContext) {
+//     printf("** checking %p\n", this);
+//     printf("   aDestroyingContext->mBits  = %0x\n", aDestroyingContext->mBits);
+//     printf("   NS_STYLE_INHERIT_BIT(Font) = %0x\n", NS_STYLE_INHERIT_BIT(Font));
+    nsInheritedStyleData& destroyingInheritedData =
+      aDestroyingContext->mCachedInheritedData;
+#define STYLE_STRUCT_INHERITED(name_, checkdata_cb)                            \
+    if (destroyingInheritedData.mStyleStructs[eStyleStruct_##name_] &&         \
+        !(aDestroyingContext->mBits & NS_STYLE_INHERIT_BIT(name_))) {          \
+      /*printf("   for " #name_ "\n");*/ \
+      MOZ_ASSERT(mCachedInheritedData.mStyleStructs[eStyleStruct_##name_] !=   \
+                 destroyingInheritedData.mStyleStructs[eStyleStruct_##name_]); \
+    }
+#define STYLE_STRUCT_RESET(name_, checkdata_cb)
+
+#include "nsStyleStructList.h"
+
+#undef STYLE_STRUCT_INHERITED
+#undef STYLE_STRUCT_RESET
+
+    if (mCachedResetData) {
+      nsResetStyleData* destroyingResetData =
+        aDestroyingContext->mCachedResetData;
+      if (destroyingResetData) {
+#define STYLE_STRUCT_INHERITED(name_, checkdata_cb_)
+#define STYLE_STRUCT_RESET(name_, checkdata_cb)                                \
+        if (destroyingResetData->mStyleStructs[eStyleStruct_##name_] &&        \
+            !(aDestroyingContext->mBits & NS_STYLE_INHERIT_BIT(name_))) {      \
+          /*printf("   for " #name_ "\n");*/ \
+          MOZ_ASSERT(mCachedResetData->mStyleStructs[eStyleStruct_##name_] !=  \
+                     destroyingResetData->mStyleStructs[eStyleStruct_##name_]);\
+        }
+
+#include "nsStyleStructList.h"
+
+#undef STYLE_STRUCT_INHERITED
+#undef STYLE_STRUCT_RESET
+      }
+    }
+  }
+
+//   if (mStyleIfVisited) {
+//     mStyleIfVisited->AssertStructsNotUsedElsewhere(aDestroyingContext);
+//   }
+
+  if (mChild) {
+    const nsStyleContext* child = mChild;
+    do {
+      child->AssertStructsNotUsedElsewhere(aDestroyingContext);
+      child = child->mNextSibling;
+    } while (child != mChild);
+  }
+
+  if (mEmptyChild) {
+    const nsStyleContext* child = mEmptyChild;
+    do {
+      child->AssertStructsNotUsedElsewhere(aDestroyingContext);
+      child = child->mNextSibling;
+    } while (child != mEmptyChild);
+  }
+}
+#endif
+
 void nsStyleContext::AddChild(nsStyleContext* aChild)
 {
   NS_ASSERTION(aChild->mPrevSibling == aChild &&
                aChild->mNextSibling == aChild,
                "child already in a child list");
 
   nsStyleContext **listPtr = aChild->mRuleNode->IsRoot() ? &mEmptyChild : &mChild;
   // Explicitly dereference listPtr so that compiler doesn't have to know that mNextSibling
@@ -143,16 +224,258 @@ void nsStyleContext::RemoveChild(nsStyle
   }
 
   aChild->mPrevSibling->mNextSibling = aChild->mNextSibling;
   aChild->mNextSibling->mPrevSibling = aChild->mPrevSibling;
   aChild->mNextSibling = aChild;
   aChild->mPrevSibling = aChild;
 }
 
+void
+nsStyleContext::RemapCachedData(const CachedDataMapping& aMapping)
+{
+  bool any = false;
+#define STYLE_STRUCT_INHERITED(name_, checkdata_cb_)                          \
+  if (aMapping[eStyleStruct_##name_].mOldData &&                              \
+      mCachedInheritedData.mStyleStructs[eStyleStruct_##name_] ==             \
+          aMapping[eStyleStruct_##name_].mOldData) {                          \
+    printf("mapping " #name_ " on %p from %p to %p\n", this, aMapping[eStyleStruct_##name_].mOldData, aMapping[eStyleStruct_##name_].mNewData); \
+    mCachedInheritedData.mStyleStructs[eStyleStruct_##name_] =                \
+      aMapping[eStyleStruct_##name_].mNewData;                                \
+    MOZ_ASSERT(mBits & NS_STYLE_INHERIT_BIT(name_)); \
+    any = true;                                                               \
+  }
+#define STYLE_STRUCT_RESET(name_, checkdata_cb_)
+
+#include "nsStyleStructList.h"
+
+#undef STYLE_STRUCT_INHERITED
+#undef STYLE_STRUCT_RESET
+
+  if (mCachedResetData) {
+#define STYLE_STRUCT_INHERITED(name_, checkdata_cb_)
+#define STYLE_STRUCT_RESET(name_, checkdata_cb_)                              \
+    if (aMapping[eStyleStruct_##name_].mOldData &&                            \
+        mCachedResetData->mStyleStructs[eStyleStruct_##name_] ==              \
+            aMapping[eStyleStruct_##name_].mOldData) {                        \
+      printf("mapping " #name_ " on %p from %p to %p\n", this, aMapping[eStyleStruct_##name_].mOldData, aMapping[eStyleStruct_##name_].mNewData); \
+      mCachedResetData->mStyleStructs[eStyleStruct_##name_] =                 \
+        aMapping[eStyleStruct_##name_].mNewData;                              \
+      MOZ_ASSERT(mBits & NS_STYLE_INHERIT_BIT(name_)); \
+      any = true;                                                             \
+    }
+
+#include "nsStyleStructList.h"
+
+#undef STYLE_STRUCT_INHERITED
+#undef STYLE_STRUCT_RESET
+  }
+
+  if (!any) {
+    return;
+  }
+
+  if (mChild) {
+    nsStyleContext* child = mChild;
+    do {
+      child->RemapCachedData(aMapping);
+      child = child->mNextSibling;
+    } while (child != mChild);
+  }
+
+  if (mEmptyChild) {
+    nsStyleContext* child = mEmptyChild;
+    do {
+      child->RemapCachedData(aMapping);
+      child = child->mNextSibling;
+    } while (child != mEmptyChild);
+  }
+}
+
+void
+nsStyleContext::MoveTo(nsStyleContext* aNewParent)
+{
+#if 0
+  // All children of this style context are moving to aNewParent.
+  // We only call this if we know that the style data in this
+  // style context's children will be the same in the their new
+  // place in the style context tree.  After all children are
+  // moved over to the new parent, this style context will
+  // end up being released.
+
+  // The descendants of this style context might have cached
+  // style struct pointers that are owned by this style context.
+  // To avoid those structs being destroyed when this style
+  // context is released, we can need to move them over to aNewParent
+  // and have it own them.
+  //
+  // We don't want to move all of the cached structs on this
+  // style context -- we will have computed new style data
+  // for some of them on the new parent style context.  We
+  // know that if a struct is cached by a child, and the
+  // pointer matches the struct cached by this style context,
+  // then it is one that must be moved over.
+
+  uint32_t cached = 0, owned = 0;
+  MOZ_ASSERT(nsCachedStyleData::GetBitForSID(
+               nsStyleStructID(nsStyleStructID_Length - 1)) <= 0xFFFFFFFF,
+             "cached and owned need to be bigger");
+
+  // See what style structs we have cached on this style context.
+
+  for (nsStyleStructID sid = nsStyleStructID_Inherited_Start;
+       sid < nsStyleStructID_Inherited_Start + nsStyleStructID_Inherited_Count;
+       sid = nsStyleStructID(sid + 1)) {
+    if (mCachedInheritedData.mStyleStructs[sid]) {
+      cached |= nsCachedStyleData::GetBitForSID(sid);
+    }
+  }
+
+  if (mCachedResetData) {
+    for (nsStyleStructID sid = nsStyleStructID_Reset_Start;
+         sid < nsStyleStructID_Reset_Start + nsStyleStructID_Reset_Count;
+         sid = nsStyleStructID(sid + 1)) {
+      if (mCachedResetData->mStyleStructs[sid]) {
+        owned |= nsCachedStyleData::GetBitForSID(sid);
+      }
+    }
+  }
+
+  // If the bit in mBits is not set, then the cached struct is owned by this
+  // style context.
+  owned = cached & ~static_cast<uint32_t>(mBits);
+
+  // For each of the owned, cached style structs, we check whether there is a
+  // child that also has that same struct cached.  If there is, we move
+  // ownership of the struct over to aNewParent.
+
+  for (nsStyleStructID sid = nsStyleStructID_Inherited_Start;
+       sid < nsStyleStructID_Inherited_Start + nsStyleStructID_Inherited_Count;
+       sid = nsStyleStructID(sid + 1)) {
+    if (owned & nsCachedStyleData::GetBitForSID(sid)) {
+      SwapDataIfChildHasItCached<Inherited>(this, aNewParent, sid);
+    }
+  }
+
+  if (mCachedResetData) {
+    for (nsStyleStructID sid = nsStyleStructID_Reset_Start;
+         sid < nsStyleStructID_Reset_Start + nsStyleStructID_Reset_Count;
+         sid = nsStyleStructID(sid + 1)) {
+      if (owned & nsCachedStyleData::GetBitForSID(sid)) {
+        SwapDataIfChildHasItCached<Reset>(this, aNewParent, sid);
+      }
+    }
+  }
+
+#if 0
+  CachedDataMapping mapping;
+  PodArrayZero(mapping);
+
+  //printf("moving %p to new parent %p\n", this, aNewParent);
+
+#define STYLE_STRUCT_INHERITED(name_, checkdata_cb_)                          \
+  if (mCachedInheritedData.mStyleStructs[eStyleStruct_##name_] &&             \
+      mCachedInheritedData.mStyleStructs[eStyleStruct_##name_] ==             \
+        mParent->mCachedInheritedData.mStyleStructs[eStyleStruct_##name_]) {  \
+    aNewParent->Style##name_();                                               \
+    if (mCachedInheritedData.mStyleStructs[eStyleStruct_##name_] !=           \
+        aNewParent->mCachedInheritedData.mStyleStructs[eStyleStruct_##name_]) {\
+      mapping[eStyleStruct_##name_].mOldData =                                \
+        mCachedInheritedData.mStyleStructs[eStyleStruct_##name_];             \
+      mapping[eStyleStruct_##name_].mNewData =                                \
+        aNewParent->mCachedInheritedData.mStyleStructs[eStyleStruct_##name_]; \
+    }                                                                         \
+  }
+#define STYLE_STRUCT_RESET(name_, checkdata_cb_)
+
+#include "nsStyleStructList.h"
+
+#undef STYLE_STRUCT_INHERITED
+#undef STYLE_STRUCT_RESET
+
+  if (mCachedResetData && mParent->mCachedResetData) {
+#define STYLE_STRUCT_INHERITED(name_, checkdata_cb_)
+#define STYLE_STRUCT_RESET(name_, checkdata_cb_)                              \
+    if (mCachedResetData->mStyleStructs[eStyleStruct_##name_] &&              \
+        mCachedResetData->mStyleStructs[eStyleStruct_##name_] ==              \
+          mParent->mCachedResetData->mStyleStructs[eStyleStruct_##name_]) {   \
+      aNewParent->Style##name_();                                             \
+      if (mCachedResetData->mStyleStructs[eStyleStruct_##name_] !=            \
+          aNewParent->mCachedResetData->mStyleStructs[eStyleStruct_##name_]) {\
+        mapping[eStyleStruct_##name_].mOldData =                              \
+          mCachedResetData->mStyleStructs[eStyleStruct_##name_];              \
+        mapping[eStyleStruct_##name_].mNewData =                              \
+          aNewParent->mCachedResetData->mStyleStructs[eStyleStruct_##name_];  \
+      }                                                                       \
+    }
+
+#include "nsStyleStructList.h"
+
+#undef STYLE_STRUCT_INHERITED
+#undef STYLE_STRUCT_RESET
+  }
+
+  RemapCachedData(mapping);
+#endif
+
+#endif
+
+  mParent->RemoveChild(this);
+  mParent->Release();
+
+  mParent = aNewParent;
+  mParent->AddRef();
+  mParent->AddChild(this);
+}
+
+void
+nsStyleContext::MoveChildrenTo(nsStyleContext* aNewParent)
+{
+  MOZ_ASSERT(!IsStyleIfVisited());
+  MOZ_ASSERT(!aNewParent->IsStyleIfVisited());
+
+  MOZ_ASSERT((mBits & NS_STYLE_INHERIT_MASK) ==
+             (aNewParent->mBits & NS_STYLE_INHERIT_MASK));
+
+  for (nsStyleStructID sid = nsStyleStructID_Inherited_Start;
+       sid < nsStyleStructID_Inherited_Start + nsStyleStructID_Inherited_Count;
+       sid = nsStyleStructID(sid + 1)) {
+    if (!(mBits & nsCachedStyleData::GetBitForSID(sid))) {
+      std::swap(mCachedInheritedData.mStyleStructs[sid],
+                aNewParent->mCachedInheritedData.mStyleStructs[sid]);
+    }
+  }
+
+  if (mCachedResetData) {
+    for (nsStyleStructID sid = nsStyleStructID_Reset_Start;
+         sid < nsStyleStructID_Reset_Start + nsStyleStructID_Reset_Count;
+         sid = nsStyleStructID(sid + 1)) {
+      if (!(mBits & nsCachedStyleData::GetBitForSID(sid))) {
+        if (!mCachedResetData) {
+          mCachedResetData = new (mRuleNode->PresContext()) nsResetStyleData;
+        }
+        std::swap(mCachedResetData->mStyleStructs[sid],
+                  aNewParent->mCachedResetData->mStyleStructs[sid]);
+      }
+    }
+  }
+
+  while (mChild) {
+    nsStyleContext* child = mChild;
+    MOZ_ASSERT(!child->IsStyleIfVisited() || child->mParent == this);
+    child->MoveTo(aNewParent);
+  }
+
+  while (mEmptyChild) {
+    nsStyleContext* child = mEmptyChild;
+    MOZ_ASSERT(!child->IsStyleIfVisited() || child->mParent == this);
+    child->MoveTo(aNewParent);
+  }
+}
+
 already_AddRefed<nsStyleContext>
 nsStyleContext::FindChildWithRules(const nsIAtom* aPseudoTag, 
                                    nsRuleNode* aRuleNode,
                                    nsRuleNode* aRulesIfVisited,
                                    bool aRelevantLinkVisited)
 {
   NS_ABORT_IF_FALSE(aRulesIfVisited || !aRelevantLinkVisited,
     "aRelevantLinkVisited should only be set when we have a separate style");
@@ -189,34 +512,97 @@ nsStyleContext::FindChildWithRules(const
   }
 
   if (result) {
     if (result != list) {
       // Move result to the front of the list.
       RemoveChild(result);
       AddChild(result);
     }
+    result->mBits |= NS_STYLE_IS_SHARED;
   }
 
   return result.forget();
 }
 
-const void* nsStyleContext::GetCachedStyleData(nsStyleStructID aSID)
+/* static */ bool
+nsStyleContext::ListContainsStyleContextThatUsesGrandancestorStyle(const nsStyleContext* aHead)
 {
-  const void* cachedData;
-  if (nsCachedStyleData::IsReset(aSID)) {
-    if (mCachedResetData) {
-      cachedData = mCachedResetData->mStyleStructs[aSID];
-    } else {
-      cachedData = nullptr;
-    }
-  } else {
-    cachedData = mCachedInheritedData.mStyleStructs[aSID];
+  if (aHead) {
+    const nsStyleContext* child = aHead;
+    do {
+      if (child->UsesGrandancestorStyle()) {
+        return true;
+      }
+      child = child->mNextSibling;
+    } while (child != aHead);
   }
-  return cachedData;
+
+  return false;
+}
+
+bool
+nsStyleContext::HasChildThatUsesGrandancestorStyle() const
+{
+  return ListContainsStyleContextThatUsesGrandancestorStyle(mEmptyChild) ||
+         ListContainsStyleContextThatUsesGrandancestorStyle(mChild);
+}
+
+/* static */ bool
+nsStyleContext::ListContainsStyleContextForPseudo(const nsStyleContext* aHead)
+{
+  if (aHead) {
+    const nsStyleContext* child = aHead;
+    do {
+      if (child->GetPseudo() && child->GetPseudo() != nsCSSAnonBoxes::mozNonElement) {
+        return true;
+      }
+      child = child->mNextSibling;
+    } while (child != aHead);
+  }
+
+  return false;
+}
+
+bool
+nsStyleContext::HasChildForPseudo() const
+{
+  return ListContainsStyleContextForPseudo(mEmptyChild) ||
+         ListContainsStyleContextForPseudo(mChild);
+}
+
+bool
+nsStyleContext::ListContainsStyleContextWithStyleIfVisited(const nsStyleContext* aHead)
+{
+  if (aHead) {
+    const nsStyleContext* child = aHead;
+    do {
+      if (child->GetStyleIfVisited()) {
+        return true;
+      }
+      child = child->mNextSibling;
+    } while (child != aHead);
+  }
+
+  return false;
+}
+
+bool
+nsStyleContext::HasChildWithStyleIfVisited() const
+{
+  return ListContainsStyleContextWithStyleIfVisited(mEmptyChild) ||
+         ListContainsStyleContextWithStyleIfVisited(mChild);
+}
+
+const void*
+nsStyleContext::GetCachedStyleData(nsStyleStructID aSID)
+{
+  return nsCachedStyleData::IsReset(aSID) ?
+           mozilla::GetCachedStyleData<Reset>(this, aSID) :
+           mozilla::GetCachedStyleData<Inherited>(this, aSID);
 }
 
 const void* nsStyleContext::StyleData(nsStyleStructID aSID)
 {
   const void* cachedData = GetCachedStyleData(aSID);
   if (cachedData)
     return cachedData; // We have computed data stored on this node in the context tree.
   return mRuleNode->GetStyleData(aSID, this, true); // Our rule node will take care of it for us.
@@ -401,25 +787,27 @@ nsStyleContext::ApplyStyleFixups(bool aS
   }
 
   // Compute User Interface style, to trigger loads of cursors
   StyleUserInterface();
 }
 
 nsChangeHint
 nsStyleContext::CalcStyleDifference(nsStyleContext* aOther,
-                                    nsChangeHint aParentHintsNotHandledForDescendants)
+                                    nsChangeHint aParentHintsNotHandledForDescendants,
+                                    bool& aAnyChanges)
 {
   //PROFILER_LABEL("nsStyleContext", "CalcStyleDifference");
 
   NS_ABORT_IF_FALSE(NS_IsHintSubset(aParentHintsNotHandledForDescendants,
                                     nsChangeHint_Hints_NotHandledForDescendants),
                     "caller is passing inherited hints, but shouldn't be");
 
   nsChangeHint hint = NS_STYLE_HINT_NONE;
+  bool anyOtherChanges = false;
   NS_ENSURE_TRUE(aOther, hint);
   // We must always ensure that we populate the structs on the new style
   // context that are filled in on the old context, so that if we get
   // two style changes in succession, the second of which causes a real
   // style change, the PeekStyleData doesn't return null (implying that
   // nobody ever looked at that struct's data).  In other words, we
   // can't skip later structs if we get a big change up front, because
   // we could later get a small change in one of those structs that we
@@ -451,33 +839,51 @@ nsStyleContext::CalcStyleDifference(nsSt
     }
   }
 
   DebugOnly<int> styleStructCount = 1;  // count Variables already
 
 #define DO_STRUCT_DIFFERENCE(struct_)                                         \
   PR_BEGIN_MACRO                                                              \
     const nsStyle##struct_* this##struct_ = PeekStyle##struct_();             \
-    if (this##struct_) {                                                      \
+    if (this##struct_) do {                                                   \
       const nsStyle##struct_* other##struct_ = aOther->Style##struct_();      \
       nsChangeHint maxDifference = nsStyle##struct_::MaxDifference();         \
       nsChangeHint maxDifferenceNeverInherited =                              \
         nsStyle##struct_::MaxDifferenceNeverInherited();                      \
-      if ((compare ||                                                         \
-           (NS_SubtractHint(maxDifference, maxDifferenceNeverInherited) &     \
-            aParentHintsNotHandledForDescendants)) &&                         \
-          !NS_IsHintSubset(maxDifference, hint) &&                            \
-          this##struct_ != other##struct_) {                                  \
-        NS_ASSERTION(NS_IsHintSubset(                                         \
-             this##struct_->CalcDifference(*other##struct_),                  \
-             nsStyle##struct_::MaxDifference()),                              \
-             "CalcDifference() returned bigger hint than MaxDifference()");   \
-        NS_UpdateHint(hint, this##struct_->CalcDifference(*other##struct_));  \
+      if (NS_IsHintSubset(maxDifference, hint)) {                             \
+        /* We've already accumulated all of the hints that CalcDifference */  \
+        /* might return for this struct.                                  */  \
+        break;                                                                \
       }                                                                       \
-    }                                                                         \
+      if (this##struct_ == other##struct_) {                                  \
+        /* The very same struct, so we know that there will be no */          \
+        /* differences.                                           */          \
+        break;                                                                \
+      }                                                                       \
+      if (compare ||                                                          \
+          (NS_SubtractHint(maxDifference, maxDifferenceNeverInherited) &      \
+           aParentHintsNotHandledForDescendants)) {                           \
+        nsChangeHint difference =                                             \
+            this##struct_->CalcDifference(*other##struct_);                   \
+        NS_ASSERTION(NS_IsHintSubset(difference, maxDifference),              \
+                     "CalcDifference() returned bigger hint than "            \
+                     "MaxDifference()");                                      \
+        NS_UpdateHint(hint, difference);                                      \
+      } else if (!hint && !anyOtherChanges) {                                 \
+        /* We still must call CalcDifference to see if there were any */      \
+        /* changes so that we can set aAnyChanges appropriately.      */      \
+        nsChangeHint difference =                                             \
+            this##struct_->CalcDifference(*other##struct_);                   \
+        NS_ASSERTION(NS_IsHintSubset(difference, maxDifference),              \
+                     "CalcDifference() returned bigger hint than "            \
+                     "MaxDifference()");                                      \
+        anyOtherChanges = !!difference;                                       \
+      }                                                                       \
+    } while (false);                                                          \
     styleStructCount++;                                                       \
   PR_END_MACRO
 
   // In general, we want to examine structs starting with those that can
   // cause the largest style change, down to those that can cause the
   // smallest.  This lets us skip later ones if we already have a hint
   // that subsumes their MaxDifference.  (As the hints get
   // finer-grained, this optimization is becoming less useful, though.)
@@ -498,17 +904,54 @@ nsStyleContext::CalcStyleDifference(nsSt
   DO_STRUCT_DIFFERENCE(SVG);
   DO_STRUCT_DIFFERENCE(Position);
   DO_STRUCT_DIFFERENCE(Font);
   DO_STRUCT_DIFFERENCE(Margin);
   DO_STRUCT_DIFFERENCE(Padding);
   DO_STRUCT_DIFFERENCE(Border);
   DO_STRUCT_DIFFERENCE(TextReset);
   DO_STRUCT_DIFFERENCE(Background);
-  DO_STRUCT_DIFFERENCE(Color);
+  // DO_STRUCT_DIFFERENCE(Color);
+
+  {
+    const nsStyleColor* thisColor = PeekStyleColor();
+    if (thisColor) do {
+      const nsStyleColor* otherColor = aOther->StyleColor();
+      nsChangeHint maxDifference = nsStyleColor::MaxDifference();
+      if (NS_IsHintSubset(maxDifference, hint)) {
+        /* We've already accumulated all of the hints that CalcDifference */
+        /* might return for this struct.                                  */
+        break;
+      }
+      if (thisColor == otherColor) {
+        /* The very same struct, so we know that there will be no */
+        /* differences.                                           */
+        break;
+      }
+      if (compare ||
+          (maxDifference & aParentHintsNotHandledForDescendants)) {
+        nsChangeHint difference =
+            thisColor->CalcDifference(*otherColor);
+        NS_ASSERTION(NS_IsHintSubset(difference, maxDifference),
+                     "CalcDifference() returned bigger hint than "
+                     "MaxDifference()");
+        NS_UpdateHint(hint, difference);
+      } else if (!hint && !anyOtherChanges) {
+        /* We still must call CalcDifference to see if there were any */
+        /* changes so that we can set aAnyChanges appropriately.      */
+        nsChangeHint difference =
+            thisColor->CalcDifference(*otherColor);
+        NS_ASSERTION(NS_IsHintSubset(difference, maxDifference),
+                     "CalcDifference() returned bigger hint than "
+                     "MaxDifference()");
+        anyOtherChanges = !!difference;
+      }
+    } while (false);
+    styleStructCount++;
+  }
 
 #undef DO_STRUCT_DIFFERENCE
 
   MOZ_ASSERT(styleStructCount == nsStyleStructID_Length,
              "missing a call to DO_STRUCT_DIFFERENCE");
 
   // Note that we do not check whether this->RelevantLinkVisited() !=
   // aOther->RelevantLinkVisited(); we don't need to since
@@ -624,17 +1067,21 @@ nsStyleContext::CalcStyleDifference(nsSt
       }
     }
 
     if (change) {
       NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
     }
   }
 
-  return hint;
+  aAnyChanges = !!hint || anyOtherChanges;
+
+  return NS_SubtractHint(hint,
+                         NS_CombineHint(nsChangeHint_NeutralChange,
+                                        nsChangeHint_InheritedNeutralChange));
 }
 
 void
 nsStyleContext::Mark()
 {
   // Mark our rule node.
   mRuleNode->Mark();
 
@@ -652,16 +1099,84 @@ nsStyleContext::Mark()
     do {
       child->Mark();
       child = child->mNextSibling;
     } while (mEmptyChild != child);
   }
 }
 
 #ifdef DEBUG
+void
+nsStyleContext::DumpStyleContextTree()
+{
+  nsStyleContext* root = this;
+  while (root->mParent) {
+    root = root->mParent;
+  }
+  root->List(stdout, 0);
+}
+
+void
+nsStyleContext::DumpStyleContextTreeStructs()
+{
+  nsStyleContext* root = this;
+  while (root->mParent) {
+    root = root->mParent;
+  }
+  root->ListWithStructs(stdout, 0);
+}
+
+void
+nsStyleContext::ListWithStructs(FILE* out, int32_t aIndent)
+{
+  // Indent
+  int32_t ix;
+  for (ix = aIndent; --ix >= 0; ) fputs("  ", out);
+  fprintf(out, "%p(%d) parent=%p ",
+          (void*)this, mRefCnt, (void *)mParent);
+  if (mPseudoTag) {
+    nsAutoString  buffer;
+    mPseudoTag->ToString(buffer);
+    fputs(NS_LossyConvertUTF16toASCII(buffer).get(), out);
+    fputs(" ", out);
+  }
+
+  fprintf(out, "Color=%p", GetCachedStyleData(eStyleStruct_Color));
+
+  if (mBits & NS_STYLE_INHERIT_BIT(Color)) {
+    fprintf(out, "(dependent)");
+  }
+
+  if (UsesGrandancestorStyle()) {
+    fprintf(out, " USES_GRANDANCESTOR_STYLE");
+  }
+  if (SharesStyleContextAllocatedObjectsWithParent()) {
+    fprintf(out, " SHARES_SC_ALLOCATED_OBJECT_WITH_PARENT");
+  }
+  if (IsShared()) {
+    fprintf(out, " SHARED");
+  }
+  fprintf(out, "\n");
+
+  if (nullptr != mChild) {
+    nsStyleContext* child = mChild;
+    do {
+      child->ListWithStructs(out, aIndent + 1);
+      child = child->mNextSibling;
+    } while (mChild != child);
+  }
+  if (nullptr != mEmptyChild) {
+    nsStyleContext* child = mEmptyChild;
+    do {
+      child->ListWithStructs(out, aIndent + 1);
+      child = child->mNextSibling;
+    } while (mEmptyChild != child);
+  }
+}
+
 void nsStyleContext::List(FILE* out, int32_t aIndent)
 {
   // Indent
   int32_t ix;
   for (ix = aIndent; --ix >= 0; ) fputs("  ", out);
   fprintf(out, "%p(%d) parent=%p ",
           (void*)this, mRefCnt, (void *)mParent);
   if (mPseudoTag) {
@@ -873,8 +1388,93 @@ nsStyleContext::AssertStyleStructMaxDiff
 {
 #define STYLE_STRUCT(name, checkdata_cb)                                     \
     MOZ_ASSERT(NS_IsHintSubset(nsStyle##name::MaxDifferenceNeverInherited(), \
                                nsStyle##name::MaxDifference()));
 #include "nsStyleStructList.h"
 #undef STYLE_STRUCT
 }
 #endif
+
+bool
+nsStyleContext::HasSameCachedStyleData(nsStyleContext* aOther,
+                                       nsStyleStructID aSID)
+{
+  return GetCachedStyleData(aSID) == aOther->GetCachedStyleData(aSID);
+}
+
+namespace mozilla {
+
+template<StyleDataType Type>
+inline const void*
+GetCachedStyleData(nsStyleContext* aContext, nsStyleStructID aSID)
+{
+  if (Type == Inherited) {
+    return aContext->mCachedInheritedData.mStyleStructs[aSID];
+  }
+
+  if (Type == ResetKnownAllocated) {
+    MOZ_ASSERT(aContext->mCachedResetData);
+  }
+
+  if (Type == Reset && !aContext->mCachedResetData) {
+    return nullptr;
+  }
+
+  return aContext->mCachedResetData->mStyleStructs[aSID];
+}
+
+template<StyleDataType Type>
+bool
+ListHasChildWithCachedStruct(nsStyleContext* aList,
+                             nsStyleStructID aSID,
+                             const void* aData)
+{
+  if (!aList) {
+    return false;
+  }
+  nsStyleContext* child = aList;
+  do {
+    if (GetCachedStyleData<Type>(child, aSID) == aData) {
+      return true;
+    }
+    child = child->mNextSibling;
+  } while (child != aList);
+  return false;
+}
+
+template<StyleDataType Type>
+void
+SwapDataIfChildHasItCached(nsStyleContext* aOldParent,
+                           nsStyleContext* aNewParent,
+                           nsStyleStructID aSID)
+{
+  static_assert(Type == Inherited || Type == Reset,
+                "don't use ResetKnownAllocated as SwapDataIfChildHasItCached's "
+                "template argument");
+
+  const void* data = Type == Reset ?
+                       GetCachedStyleData<ResetKnownAllocated>(aOldParent, aSID) :
+                       GetCachedStyleData<Inherited>(aOldParent, aSID);
+
+  MOZ_ASSERT(data, "we should have already verified this is non-null");
+
+  if (!ListHasChildWithCachedStruct<Type>(aOldParent->mChild, aSID, data) &&
+      !ListHasChildWithCachedStruct<Type>(aOldParent->mEmptyChild, aSID, data)) {
+    // There was no child that inherited the owned cached struct, so we don't
+    // need to do any swapping.
+    return;
+  }
+
+  MOZ_ASSERT(!(aNewParent->mBits & nsCachedStyleData::GetBitForSID(aSID)),
+             "do we really need to handle swapping with an inherited "
+             "cached struct?");
+
+  const void* other =
+    Type == Reset ?
+      GetCachedStyleData<ResetKnownAllocated>(aNewParent, aSID) :
+      GetCachedStyleData<Inherited>(aNewParent, aSID);
+
+  aOldParent->SetStyle(aSID, const_cast<void*>(other));
+  aNewParent->SetStyle(aSID, const_cast<void*>(data));
+}
+
+}
diff --git a/layout/style/nsStyleContext.h b/layout/style/nsStyleContext.h
--- a/layout/style/nsStyleContext.h
+++ b/layout/style/nsStyleContext.h
@@ -8,16 +8,46 @@
 #ifndef _nsStyleContext_h_
 #define _nsStyleContext_h_
 
 #include "nsRuleNode.h"
 #include "nsCSSPseudoElements.h"
 
 class nsIAtom;
 class nsPresContext;
+class nsStyleContext;
+
+namespace mozilla {
+// Templated version of nsStyleContext::GetCachedStyleData that can be used when
+// we know ahead of time whether the given style struct is inherited or reset,
+// and for reset structs, whether we know that mCachedResetData has already been
+// allocated.
+
+enum StyleDataType {
+  Inherited,
+  Reset,
+  ResetKnownAllocated
+};
+
+template<StyleDataType Type>
+inline const void*
+GetCachedStyleData(nsStyleContext* aContext, nsStyleStructID aSID);
+
+template<StyleDataType Type>
+bool
+ListHasChildWithCachedStruct(nsStyleContext* aList,
+                             nsStyleStructID aSID,
+                             const void* aData);
+
+template<StyleDataType Type>
+void
+SwapDataIfChildHasItCached(nsStyleContext* aOldParent,
+                           nsStyleContext* aNewParent,
+                           nsStyleStructID aSID);
+} // namespace mozilla
 
 /**
  * An nsStyleContext represents the computed style data for an element.
  * The computed style data are stored in a set of structs (see
  * nsStyleStruct.h) that are cached either on the style context or in
  * the rule tree (see nsRuleNode.h for a description of this caching and
  * how the cached structs are shared).
  *
@@ -33,16 +63,30 @@ class nsPresContext;
  *  2. any *child* style contexts (this might be the reverse of
  *     expectation, but it makes sense in this case)
  * Style contexts participate in the mark phase of rule node garbage
  * collection.
  */
 
 class nsStyleContext
 {
+  template<mozilla::StyleDataType Type>
+  friend const void* mozilla::GetCachedStyleData(nsStyleContext* aContext,
+                                                 nsStyleStructID aSID);
+
+  template<mozilla::StyleDataType Type>
+  friend bool mozilla::ListHasChildWithCachedStruct(nsStyleContext* aList,
+                                                    nsStyleStructID aSID,
+                                                    const void* aData);
+
+  template<mozilla::StyleDataType Type>
+  friend void mozilla::SwapDataIfChildHasItCached(nsStyleContext* aOldParent,
+                                                  nsStyleContext* aNewParent,
+                                                  nsStyleStructID aSID);
+
 public:
   /**
    * Create a new style context.
    * @param aParent  The parent of a style context is used for CSS
    *                 inheritance.  When the element or pseudo-element
    *                 this style context represents the style data of
    *                 inherits a CSS property, the value comes from the
    *                 parent style context.  This means style context
@@ -187,16 +231,45 @@ public:
                    GetStyleIfVisited()->GetParent() == GetParent(),
                    "parent mismatch");
     } else {
       NS_ASSERTION(GetStyleIfVisited()->GetParent() == GetParent(),
                    "parent mismatch");
     }
   }
 
+  // Does this style context, or any of its descendants, have any style values
+  // that were computed based on its grandparent style context or any of the
+  // grandparent's ancestors?
+  bool UsesGrandancestorStyle() const
+    { return !!(mBits & NS_STYLE_USES_GRANDANCESTOR_STYLE); }
+
+  // Do this style context have a reference to an object allocated by an
+  // ancestor style context?
+  bool SharesStyleContextAllocatedObjectsWithParent() const
+    { return !!(mBits & NS_STYLE_SHARES_SC_ALLOCATED_OBJECT_WITH_PARENT); }
+
+  // Is this style context shared with a sibling or cousin?
+  // (See nsStyleSet::GetContext.)
+  bool IsShared() const
+    { return !!(mBits & NS_STYLE_IS_SHARED); }
+
+  // Does this style context have any children that return true for
+  // UsesGrandancestorStyle()?
+  bool HasChildThatUsesGrandancestorStyle() const;
+  static bool ListContainsStyleContextThatUsesGrandancestorStyle(const nsStyleContext* aHead);
+
+  // Do this style context have any children whose pseudo type is not
+  // ePseudo_NotPseudoElement?
+  bool HasChildForPseudo() const;
+  static bool ListContainsStyleContextForPseudo(const nsStyleContext* aHead);
+
+  bool HasChildWithStyleIfVisited() const;
+  static bool ListContainsStyleContextWithStyleIfVisited(const nsStyleContext* aHead);
+
   // Tell this style context to cache aStruct as the struct for aSID
   void SetStyle(nsStyleStructID aSID, void* aStruct);
 
   // Setters for inherit structs only, since rulenode only sets those eagerly.
   #define STYLE_STRUCT_INHERITED(name_, checkdata_cb_)                      \
     void SetStyle##name_ (nsStyle##name_ * aStruct) {                       \
       void *& slot =                                                        \
         mCachedInheritedData.mStyleStructs[eStyleStruct_##name_];           \
@@ -206,16 +279,18 @@ public:
                    "Going to leak styledata");                              \
       slot = aStruct;                                                       \
     }
 #define STYLE_STRUCT_RESET(name_, checkdata_cb_) /* nothing */
   #include "nsStyleStructList.h"
   #undef STYLE_STRUCT_RESET
   #undef STYLE_STRUCT_INHERITED
 
+  bool HasSameCachedStyleData(nsStyleContext* aOther, nsStyleStructID aSID);
+
   nsRuleNode* RuleNode() { return mRuleNode; }
   void AddStyleBit(const uint64_t& aBit) { mBits |= aBit; }
 
   /*
    * Mark this style context's rule node (and its ancestors) to prevent
    * it from being garbage collected.
    */
   void Mark();
@@ -280,17 +355,18 @@ public:
    * hints) also apply to all descendants.  The caller must pass in any
    * non-inherited hints that resulted from the parent style context's
    * style change.  The caller *may* pass more hints than needed, but
    * must not pass less than needed; therefore if the caller doesn't
    * know, the caller should pass
    * nsChangeHint_Hints_NotHandledForDescendants.
    */
   nsChangeHint CalcStyleDifference(nsStyleContext* aOther,
-                                   nsChangeHint aParentHintsNotHandledForDescendants);
+                                   nsChangeHint aParentHintsNotHandledForDescendants,
+                                   bool& aAnyChanges);
 
   /**
    * Get a color that depends on link-visitedness using this and
    * this->GetStyleIfVisited().
    *
    * aProperty must be a color-valued property that nsStyleAnimation
    * knows how to extract.  It must also be a property that we know to
    * do change handling for in nsStyleContext::CalcDifference.
@@ -334,18 +410,24 @@ public:
   /**
    * Start the background image loads for this style context.
    */
   void StartBackgroundImageLoads() {
     // Just get our background struct; that should do the trick
     StyleBackground();
   }
 
+  void MoveTo(nsStyleContext* aNewParent);
+  void MoveChildrenTo(nsStyleContext* aNewParent);
+
 #ifdef DEBUG
+  void DumpStyleContextTree();
+  void DumpStyleContextTreeStructs();
   void List(FILE* out, int32_t aIndent);
+  void ListWithStructs(FILE* out, int32_t aIndent);
   static void AssertStyleStructMaxDifferenceValid();
 #endif
 
 protected:
   void AddChild(nsStyleContext* aChild);
   void RemoveChild(nsStyleContext* aChild);
 
   void ApplyStyleFixups(bool aSkipFlexItemStyleFixup);
@@ -377,17 +459,30 @@ protected:
         return cachedData;                                              \
       /* Have the rulenode deal */                                      \
       return mRuleNode->GetStyle##name_(this, aComputeData);            \
     }
   #include "nsStyleStructList.h"
   #undef STYLE_STRUCT_RESET
   #undef STYLE_STRUCT_INHERITED
 
-  nsStyleContext* const mParent; // STRONG
+  struct CachedDataMappingEntry
+  {
+    void* mOldData;
+    void* mNewData;
+  };
+  typedef CachedDataMappingEntry CachedDataMapping[nsStyleStructID_Length];
+
+  void RemapCachedData(const CachedDataMapping& aMapping);
+
+#ifdef DEBUG
+  void AssertStructsNotUsedElsewhere(nsStyleContext* aDestroyingContext) const;
+#endif
+
+  nsStyleContext* mParent; // STRONG
 
   // Children are kept in two circularly-linked lists.  The list anchor
   // is not part of the list (null for empty), and we point to the first
   // child.
   // mEmptyChild for children whose rule node is the root rule node, and
   // mChild for other children.  The order of children is not
   // meaningful.
   nsStyleContext* mChild;
@@ -427,20 +522,28 @@ protected:
   // style context owns a reference to its parent).  If the bit in |mBits|
   // is set for a struct, that means that the pointer for that struct is
   // owned by an ancestor or by mRuleNode rather than by this style context.
   // Since style contexts typically have some inherited data but only sometimes
   // have reset data, we always allocate the mCachedInheritedData, but only
   // sometimes allocate the mCachedResetData.
   nsResetStyleData*       mCachedResetData; // Cached reset style data.
   nsInheritedStyleData    mCachedInheritedData; // Cached inherited style data
+public:
   uint64_t                mBits; // Which structs are inherited from the
                                  // parent context or owned by mRuleNode.
+private:
   uint32_t                mRefCnt;
 };
 
 already_AddRefed<nsStyleContext>
 NS_NewStyleContext(nsStyleContext* aParentContext,
                    nsIAtom* aPseudoTag,
                    nsCSSPseudoElements::Type aPseudoType,
                    nsRuleNode* aRuleNode,
                    bool aSkipFlexItemStyleFixup);
+
+namespace mozilla {
+
+
+}
+
 #endif
diff --git a/layout/style/nsStyleCoord.h b/layout/style/nsStyleCoord.h
--- a/layout/style/nsStyleCoord.h
+++ b/layout/style/nsStyleCoord.h
@@ -80,16 +80,22 @@ public:
   {
     mUnit = aOther.mUnit;
     mValue = aOther.mValue;
     return *this;
   }
   bool           operator==(const nsStyleCoord& aOther) const;
   bool           operator!=(const nsStyleCoord& aOther) const;
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleCoord& aOther) const {
+    return IsCalcUnit() &&
+           aOther.IsCalcUnit() &&
+           GetCalcValue() == aOther.GetCalcValue();
+  }
+
   nsStyleUnit GetUnit() const {
     NS_ASSERTION(mUnit != eStyleUnit_Null, "reading uninitialized value");
     return mUnit;
   }
 
   bool IsAngleValue() const {
     return eStyleUnit_Degree <= mUnit && mUnit <= eStyleUnit_Turn;
   }
@@ -160,16 +166,27 @@ private:
 class nsStyleSides {
 public:
   nsStyleSides();
 
 //  nsStyleSides&  operator=(const nsStyleSides& aCopy);  // use compiler's version
   bool           operator==(const nsStyleSides& aOther) const;
   bool           operator!=(const nsStyleSides& aOther) const;
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleSides& aOther) const {
+    for (uint32_t i = 0; i < 4; i++) {
+      if (mUnits[i] == eStyleUnit_Calc &&
+          aOther.mUnits[i] == eStyleUnit_Calc &&
+          mValues[i].mPointer != aOther.mValues[i].mPointer) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   inline nsStyleUnit GetUnit(mozilla::css::Side aSide) const;
   inline nsStyleUnit GetLeftUnit() const;
   inline nsStyleUnit GetTopUnit() const;
   inline nsStyleUnit GetRightUnit() const;
   inline nsStyleUnit GetBottomUnit() const;
 
   inline nsStyleCoord Get(mozilla::css::Side aSide) const;
   inline nsStyleCoord GetLeft() const;
@@ -199,16 +216,27 @@ class nsStyleCorners {
 public:
   nsStyleCorners();
 
   // use compiler's version
   //nsStyleCorners&  operator=(const nsStyleCorners& aCopy);
   bool           operator==(const nsStyleCorners& aOther) const;
   bool           operator!=(const nsStyleCorners& aOther) const;
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleCorners& aOther) const {
+    for (uint32_t i = 0; i < 8; i++) {
+      if (mUnits[i] == eStyleUnit_Calc &&
+          aOther.mUnits[i] == eStyleUnit_Calc &&
+          mValues[i].mPointer != aOther.mValues[i].mPointer) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   // aCorner is always one of NS_CORNER_* defined in nsStyleConsts.h
   inline nsStyleUnit GetUnit(uint8_t aHalfCorner) const;
 
   inline nsStyleCoord Get(uint8_t aHalfCorner) const;
 
   void  Reset();
 
   inline void Set(uint8_t aHalfCorner, const nsStyleCoord& aCoord);
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -195,17 +195,31 @@ nsChangeHint nsStyleFont::CalcDifference
              "expected mAllowZoom to be the same on both nsStyleFonts");
   if (mSize != aOther.mSize ||
       mLanguage != aOther.mLanguage ||
       mExplicitLanguage != aOther.mExplicitLanguage ||
       mMathVariant != aOther.mMathVariant ||
       mMathDisplay != aOther.mMathDisplay) {
     return NS_STYLE_HINT_REFLOW;
   }
-  return CalcFontDifference(mFont, aOther.mFont);
+
+  nsChangeHint hint = CalcFontDifference(mFont, aOther.mFont);
+  if (hint) {
+    return hint;
+  }
+
+  if (mGenericID != aOther.mGenericID ||
+      mScriptLevel != aOther.mScriptLevel ||
+      mScriptUnconstrainedSize != aOther.mScriptUnconstrainedSize ||
+      mScriptMinSize != aOther.mScriptMinSize ||
+      mScriptSizeMultiplier != aOther.mScriptSizeMultiplier) {
+    return nsChangeHint_InheritedNeutralChange;
+  }
+
+  return NS_STYLE_HINT_NONE;
 }
 
 /* static */ nscoord
 nsStyleFont::ZoomText(nsPresContext *aPresContext, nscoord aSize)
 {
   return nscoord(float(aSize) * aPresContext->TextZoom());
 }
 
@@ -515,18 +529,16 @@ nsChangeHint nsStyleBorder::CalcDifferen
 {
   nsChangeHint shadowDifference =
     CalcShadowDifference(mBoxShadow, aOther.mBoxShadow);
   NS_ABORT_IF_FALSE(shadowDifference == unsigned(NS_STYLE_HINT_REFLOW) ||
                     shadowDifference == unsigned(NS_STYLE_HINT_VISUAL) ||
                     shadowDifference == unsigned(NS_STYLE_HINT_NONE),
                     "should do more with shadowDifference");
 
-  // Note that differences in mBorder don't affect rendering (which should only
-  // use mComputedBorder), so don't need to be tested for here.
   // XXXbz we should be able to return a more specific change hint for
   // at least GetComputedBorder() differences...
   if (mTwipsPerPixel != aOther.mTwipsPerPixel ||
       GetComputedBorder() != aOther.GetComputedBorder() ||
       mFloatEdge != aOther.mFloatEdge ||
       mBorderImageOutset != aOther.mBorderImageOutset ||
       (shadowDifference & nsChangeHint_NeedReflow))
     return NS_STYLE_HINT_REFLOW;
@@ -574,17 +586,28 @@ nsChangeHint nsStyleBorder::CalcDifferen
   if (mBorderColors) {
     NS_FOR_CSS_SIDES(ix) {
       if (!nsBorderColors::Equal(mBorderColors[ix],
                                  aOther.mBorderColors[ix]))
         return NS_STYLE_HINT_VISUAL;
     }
   }
 
-  return shadowDifference;
+  if (shadowDifference) {
+    return shadowDifference;
+  }
+
+  // mBorder is the specified border value.  Changes to this don't
+  // need any change processing, since we operate on the computed
+  // border values instead.
+  if (mBorder != aOther.mBorder) {
+    return nsChangeHint_NeutralChange;
+  }
+
+  return NS_STYLE_HINT_NONE;
 }
 
 nsStyleOutline::nsStyleOutline(nsPresContext* aPresContext)
 {
   MOZ_COUNT_CTOR(nsStyleOutline);
   // spacing values not inherited
   nsStyleCoord zero(0, nsStyleCoord::CoordConstructor);
   NS_FOR_CSS_HALF_CORNERS(corner) {
@@ -637,16 +660,25 @@ nsChangeHint nsStyleOutline::CalcDiffere
     return NS_CombineHint(nsChangeHint_AllReflowHints,
                           nsChangeHint_RepaintFrame);
   }
   if ((mOutlineStyle != aOther.mOutlineStyle) ||
       (mOutlineColor != aOther.mOutlineColor) ||
       (mOutlineRadius != aOther.mOutlineRadius)) {
     return nsChangeHint_RepaintFrame;
   }
+  // XXX Not exactly sure if we need to check the cached outline values.
+  if (mOutlineWidth != aOther.mOutlineWidth ||
+      mOutlineOffset != aOther.mOutlineOffset ||
+      mTwipsPerPixel != aOther.mTwipsPerPixel ||
+      mHasCachedOutline != aOther.mHasCachedOutline ||
+      (mHasCachedOutline &&
+       (mCachedOutlineWidth != aOther.mCachedOutlineWidth))) {
+    return nsChangeHint_NeutralChange;
+  }
   return NS_STYLE_HINT_NONE;
 }
 
 // --------------------
 // nsStyleList
 //
 nsStyleList::nsStyleList() 
   : mListStyleType(NS_STYLE_LIST_STYLE_DISC),
@@ -773,16 +805,21 @@ nsChangeHint nsStyleColumn::CalcDifferen
     return NS_STYLE_HINT_REFLOW;
 
   if (GetComputedColumnRuleWidth() != aOther.GetComputedColumnRuleWidth() ||
       mColumnRuleStyle != aOther.mColumnRuleStyle ||
       mColumnRuleColor != aOther.mColumnRuleColor ||
       mColumnRuleColorIsForeground != aOther.mColumnRuleColorIsForeground)
     return NS_STYLE_HINT_VISUAL;
 
+  if (mColumnRuleWidth != aOther.mColumnRuleWidth ||
+      mTwipsPerPixel != aOther.mTwipsPerPixel) {
+    return nsChangeHint_NeutralChange;
+  }
+
   return NS_STYLE_HINT_NONE;
 }
 
 // --------------------
 // nsStyleSVG
 //
 nsStyleSVG::nsStyleSVG() 
 {
@@ -1532,22 +1569,24 @@ nsChangeHint nsStyleTableBorder::CalcDif
 }
 
 // --------------------
 // nsStyleColor
 //
 
 nsStyleColor::nsStyleColor(nsPresContext* aPresContext)
 {
+  // printf(" nsStyleColor %p\n", this);
   MOZ_COUNT_CTOR(nsStyleColor);
   mColor = aPresContext->DefaultColor();
 }
 
 nsStyleColor::nsStyleColor(const nsStyleColor& aSource)
 {
+  // printf(" nsStyleColor %p\n", this);
   MOZ_COUNT_CTOR(nsStyleColor);
   mColor = aSource.mColor;
 }
 
 nsChangeHint nsStyleColor::CalcDifference(const nsStyleColor& aOther) const
 {
   if (mColor == aOther.mColor)
     return NS_STYLE_HINT_NONE;
@@ -2046,16 +2085,26 @@ nsChangeHint nsStyleBackground::CalcDiff
     }
   }
 
   if (hasVisualDifference ||
       mBackgroundColor != aOther.mBackgroundColor ||
       mBackgroundInlinePolicy != aOther.mBackgroundInlinePolicy)
     return NS_STYLE_HINT_VISUAL;
 
+  if (mAttachmentCount != aOther.mAttachmentCount ||
+      mClipCount != aOther.mClipCount ||
+      mOriginCount != aOther.mOriginCount ||
+      mRepeatCount != aOther.mRepeatCount ||
+      mPositionCount != aOther.mPositionCount ||
+      mImageCount != aOther.mImageCount ||
+      mSizeCount != aOther.mSizeCount) {
+    return nsChangeHint_NeutralChange;
+  }
+
   return NS_STYLE_HINT_NONE;
 }
 
 bool nsStyleBackground::HasFixedBackground() const
 {
   NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(i, this) {
     const Layer &layer = mLayers[i];
     if (layer.mAttachment == NS_STYLE_BG_ATTACHMENT_FIXED &&
@@ -2305,16 +2354,27 @@ void nsTransition::SetUnknownProperty(co
   NS_ASSERTION(nsCSSProps::LookupProperty(aUnknownProperty,
                                           nsCSSProps::eEnabledForAllContent) ==
                  eCSSProperty_UNKNOWN,
                "should be unknown property");
   mProperty = eCSSProperty_UNKNOWN;
   mUnknownProperty = do_GetAtom(aUnknownProperty);
 }
 
+bool
+nsTransition::operator==(const nsTransition& aOther) const
+{
+  return mTimingFunction == aOther.mTimingFunction &&
+         mDuration == aOther.mDuration &&
+         mDelay == aOther.mDelay &&
+         mProperty == aOther.mProperty &&
+         (mProperty != eCSSProperty_UNKNOWN ||
+          mUnknownProperty == aOther.mUnknownProperty);
+}
+
 nsAnimation::nsAnimation(const nsAnimation& aCopy)
   : mTimingFunction(aCopy.mTimingFunction)
   , mDuration(aCopy.mDuration)
   , mDelay(aCopy.mDelay)
   , mName(aCopy.mName)
   , mDirection(aCopy.mDirection)
   , mFillMode(aCopy.mFillMode)
   , mPlayState(aCopy.mPlayState)
@@ -2330,16 +2390,29 @@ nsAnimation::SetInitialValues()
   mDelay = 0.0;
   mName = EmptyString();
   mDirection = NS_STYLE_ANIMATION_DIRECTION_NORMAL;
   mFillMode = NS_STYLE_ANIMATION_FILL_MODE_NONE;
   mPlayState = NS_STYLE_ANIMATION_PLAY_STATE_RUNNING;
   mIterationCount = 1.0f;
 }
 
+bool
+nsAnimation::operator==(const nsAnimation& aOther) const
+{
+  return mTimingFunction == aOther.mTimingFunction &&
+         mDuration == aOther.mDuration &&
+         mDelay == aOther.mDelay &&
+         mName == aOther.mName &&
+         mDirection == aOther.mDirection &&
+         mFillMode == aOther.mFillMode &&
+         mPlayState == aOther.mPlayState &&
+         mIterationCount == aOther.mIterationCount;
+}
+
 nsStyleDisplay::nsStyleDisplay()
   : mWillChangeBitField(0)
 {
   MOZ_COUNT_CTOR(nsStyleDisplay);
   mAppearance = NS_THEME_NONE;
   mDisplay = NS_STYLE_DISPLAY_INLINE;
   mOriginalDisplay = mDisplay;
   mPosition = NS_STYLE_POSITION_STATIC;
@@ -2483,17 +2556,18 @@ nsChangeHint nsStyleDisplay::CalcDiffere
   // necessarily require a repaint, reflow should suffice.
   if (mBreakType != aOther.mBreakType
       || mBreakInside != aOther.mBreakInside
       || mBreakBefore != aOther.mBreakBefore
       || mBreakAfter != aOther.mBreakAfter
       || mAppearance != aOther.mAppearance
       || mOrient != aOther.mOrient
       || mOverflowClipBox != aOther.mOverflowClipBox
-      || mClipFlags != aOther.mClipFlags || !mClip.IsEqualInterior(aOther.mClip))
+      || mClipFlags != aOther.mClipFlags
+      || !mClip.IsEqualInterior(aOther.mClip))
     NS_UpdateHint(hint, NS_CombineHint(nsChangeHint_AllReflowHints,
                                        nsChangeHint_RepaintFrame));
 
   if (mOpacity != aOther.mOpacity) {
     // If we're going from the optimized >=0.99 opacity value to 1.0 or back, then
     // repaint the frame because DLBI will not catch the invalidation.  Otherwise,
     // just update the opacity layer.
     if ((mOpacity >= 0.99f && mOpacity < 1.0f && aOther.mOpacity == 1.0f) ||
@@ -2545,16 +2619,34 @@ nsChangeHint nsStyleDisplay::CalcDiffere
 
     if (mChildPerspective != aOther.mChildPerspective ||
         mTransformStyle != aOther.mTransformStyle)
       NS_UpdateHint(hint, kUpdateOverflowAndRepaintHint);
 
     if (mBackfaceVisibility != aOther.mBackfaceVisibility)
       NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
   }
+  else {
+    for (uint8_t index = 0; index < 3; ++index)
+      if (mTransformOrigin[index] != aOther.mTransformOrigin[index]) {
+        NS_UpdateHint(hint, nsChangeHint_NeutralChange);
+        break;
+      }
+
+    for (uint8_t index = 0; index < 2; ++index)
+      if (mPerspectiveOrigin[index] != aOther.mPerspectiveOrigin[index]) {
+        NS_UpdateHint(hint, nsChangeHint_NeutralChange);
+        break;
+      }
+
+    if (mChildPerspective != aOther.mChildPerspective ||
+        mTransformStyle != aOther.mTransformStyle ||
+        mBackfaceVisibility != aOther.mBackfaceVisibility)
+      NS_UpdateHint(hint, nsChangeHint_NeutralChange);
+  }
 
   uint8_t willChangeBitsChanged =
     mWillChangeBitField ^ aOther.mWillChangeBitField;
   if (willChangeBitsChanged & NS_STYLE_WILL_CHANGE_STACKING_CONTEXT) {
     NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
   }
   if (willChangeBitsChanged & ~uint8_t(NS_STYLE_WILL_CHANGE_STACKING_CONTEXT)) {
     // FIXME (Bug 974125): Don't reconstruct the frame
@@ -2570,16 +2662,42 @@ nsChangeHint nsStyleDisplay::CalcDiffere
   // We do handle changes to transition-property, but we don't need to
   // bother with anything here, since the transition manager is notified
   // of any style context change anyway.
 
   // Note: Likewise, for animation-*, the animation manager gets
   // notified about every new style context constructed, and it uses
   // that opportunity to handle dynamic changes appropriately.
 
+  // But we still need to return nsChangeHint_NeutralChange for these
+  // properties, since some data did change in the style struct.
+
+  if (!hint &&
+      (mClip.TopLeft() != aOther.mClip.TopLeft() ||
+       mOriginalDisplay != aOther.mOriginalDisplay ||
+       mOriginalFloats != aOther.mOriginalFloats ||
+       mMixBlendMode != aOther.mMixBlendMode ||
+       mTransitions != aOther.mTransitions ||
+       mTransitionTimingFunctionCount !=
+         aOther.mTransitionTimingFunctionCount ||
+       mTransitionDurationCount != aOther.mTransitionDurationCount ||
+       mTransitionDelayCount != aOther.mTransitionDelayCount ||
+       mTransitionPropertyCount != aOther.mTransitionPropertyCount ||
+       mAnimations != aOther.mAnimations ||
+       mAnimationTimingFunctionCount != aOther.mAnimationTimingFunctionCount ||
+       mAnimationDurationCount != aOther.mAnimationDurationCount ||
+       mAnimationDelayCount != aOther.mAnimationDelayCount ||
+       mAnimationNameCount != aOther.mAnimationNameCount ||
+       mAnimationDirectionCount != aOther.mAnimationDirectionCount ||
+       mAnimationFillModeCount != aOther.mAnimationFillModeCount ||
+       mAnimationPlayStateCount != aOther.mAnimationPlayStateCount ||
+       mAnimationIterationCountCount != aOther.mAnimationIterationCountCount)) {
+    NS_UpdateHint(hint, nsChangeHint_NeutralChange);
+  }
+
   return hint;
 }
 
 // --------------------
 // nsStyleVisibility
 //
 
 nsStyleVisibility::nsStyleVisibility(nsPresContext* aPresContext)
@@ -3209,23 +3327,28 @@ nsChangeHint nsStyleUserInterface::CalcD
   // We could do better. But it wouldn't be worth it, URL-specified cursors are
   // rare.
   if (mCursorArrayLength > 0 || aOther.mCursorArrayLength > 0)
     NS_UpdateHint(hint, nsChangeHint_UpdateCursor);
 
   if (mUserModify != aOther.mUserModify)
     NS_UpdateHint(hint, NS_STYLE_HINT_VISUAL);
   
-  if ((mUserInput != aOther.mUserInput) &&
-      ((NS_STYLE_USER_INPUT_NONE == mUserInput) || 
-       (NS_STYLE_USER_INPUT_NONE == aOther.mUserInput))) {
-    NS_UpdateHint(hint, NS_STYLE_HINT_FRAMECHANGE);
+  if (mUserInput != aOther.mUserInput) {
+    if (NS_STYLE_USER_INPUT_NONE == mUserInput ||
+        NS_STYLE_USER_INPUT_NONE == aOther.mUserInput) {
+      NS_UpdateHint(hint, NS_STYLE_HINT_FRAMECHANGE);
+    } else {
+      NS_UpdateHint(hint, nsChangeHint_InheritedNeutralChange);
+    }
   }
 
-  // ignore mUserFocus
+  if (mUserFocus != aOther.mUserFocus) {
+    NS_UpdateHint(hint, nsChangeHint_InheritedNeutralChange);
+  }
 
   return hint;
 }
 
 void
 nsStyleUserInterface::CopyCursorArrayFrom(const nsStyleUserInterface& aSource)
 {
   mCursorArray = nullptr;
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -46,19 +46,25 @@ class imgIContainer;
 // See nsStyleContext::HasTextDecorationLines
 #define NS_STYLE_HAS_TEXT_DECORATION_LINES 0x001000000
 // See nsStyleContext::HasPseudoElementData.
 #define NS_STYLE_HAS_PSEUDO_ELEMENT_DATA   0x002000000
 // See nsStyleContext::RelevantLinkIsVisited
 #define NS_STYLE_RELEVANT_LINK_VISITED     0x004000000
 // See nsStyleContext::IsStyleIfVisited
 #define NS_STYLE_IS_STYLE_IF_VISITED       0x008000000
+// See nsStyleContext::UsesGrandancestorStyle
+#define NS_STYLE_USES_GRANDANCESTOR_STYLE  0x010000000
+// See nsStyleContext::SharesStyleContextAllocatedObjectsWithParent
+#define NS_STYLE_SHARES_SC_ALLOCATED_OBJECT_WITH_PARENT  0x20000000
+// See nsStyleContext::IsShared
+#define NS_STYLE_IS_SHARED                 0x40000000
 // See nsStyleContext::GetPseudoEnum
-#define NS_STYLE_CONTEXT_TYPE_MASK         0x1f0000000
-#define NS_STYLE_CONTEXT_TYPE_SHIFT        28
+#define NS_STYLE_CONTEXT_TYPE_MASK        0xf80000000
+#define NS_STYLE_CONTEXT_TYPE_SHIFT       31
 
 // Additional bits for nsRuleNode's mDependentBits:
 #define NS_RULE_NODE_GC_MARK                0x02000000
 #define NS_RULE_NODE_USED_DIRECTLY          0x04000000
 #define NS_RULE_NODE_IS_IMPORTANT           0x08000000
 #define NS_RULE_NODE_LEVEL_MASK             0xf0000000
 #define NS_RULE_NODE_LEVEL_SHIFT            28
 
@@ -72,32 +78,37 @@ private:
   void Init(nsPresContext *aPresContext);
 public:
   ~nsStyleFont(void) {
     MOZ_COUNT_DTOR(nsStyleFont);
   }
 
   nsChangeHint CalcDifference(const nsStyleFont& aOther) const;
   static nsChangeHint MaxDifference() {
-    return NS_STYLE_HINT_REFLOW;
+    return NS_CombineHint(NS_STYLE_HINT_REFLOW,
+                          nsChangeHint_InheritedNeutralChange);
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference never returns nsChangeHint_NeedReflow or
     // nsChangeHint_ClearAncestorIntrinsics as inherited hints.
     return NS_CombineHint(nsChangeHint_NeedReflow,
                           nsChangeHint_ClearAncestorIntrinsics);
   }
   static nsChangeHint CalcFontDifference(const nsFont& aFont1, const nsFont& aFont2);
 
   static nscoord ZoomText(nsPresContext* aPresContext, nscoord aSize);
   static nscoord UnZoomText(nsPresContext* aPresContext, nscoord aSize);
 
   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW;
   void Destroy(nsPresContext* aContext);
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleFont& aOther) const {
+    return false;
+  }
+
   void EnableZoom(nsPresContext* aContext, bool aEnable);
 
   nsFont  mFont;        // [inherited]
   nscoord mSize;        // [inherited] Our "computed size". Can be different
                         // from mFont.size which is our "actual size" and is
                         // enforced to be >= the user's preferred min-size.
                         // mFont.size should be used for display purposes
                         // while mSize is the value to return in
@@ -122,16 +133,20 @@ public:
   // The value mSize would have had if scriptminsize had never been applied
   nscoord mScriptUnconstrainedSize;
   nscoord mScriptMinSize;        // [inherited] length
   float   mScriptSizeMultiplier; // [inherited]
   nsCOMPtr<nsIAtom> mLanguage;   // [inherited]
 };
 
 struct nsStyleGradientStop {
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleGradientStop& aOther) const {
+    return mLocation.SharesStyleContextAllocatedObjectsWith(aOther.mLocation);
+  }
+
   nsStyleCoord mLocation; // percent, coord, calc, none
   nscolor mColor;
 };
 
 class nsStyleGradient {
 public:
   nsStyleGradient();
   uint8_t mShape;  // NS_STYLE_GRADIENT_SHAPE_*
@@ -150,16 +165,37 @@ public:
   // stops are in the order specified in the stylesheet
   nsTArray<nsStyleGradientStop> mStops;
 
   bool operator==(const nsStyleGradient& aOther) const;
   bool operator!=(const nsStyleGradient& aOther) const {
     return !(*this == aOther);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleGradient& aOther) const {
+    MOZ_ASSERT(!mAngle.SharesStyleContextAllocatedObjectsWith(mAngle));
+    if (mStops.Length() != aOther.mStops.Length()) {
+#ifdef DEBUG
+      for (uint32_t i = 0; i < std::min(mStops.Length(), aOther.mStops.Length()); i++) {
+        MOZ_ASSERT(!mStops[i].SharesStyleContextAllocatedObjectsWith(aOther.mStops[i]));
+      }
+#endif
+    } else {
+      for (uint32_t i = 0; i < mStops.Length(); i++) {
+        if (mStops[i].SharesStyleContextAllocatedObjectsWith(aOther.mStops[i])) {
+          return true;
+        }
+      }
+    }
+    return mBgPosX.SharesStyleContextAllocatedObjectsWith(aOther.mBgPosX) ||
+           mBgPosY.SharesStyleContextAllocatedObjectsWith(aOther.mBgPosY) ||
+           mRadiusX.SharesStyleContextAllocatedObjectsWith(aOther.mRadiusX) ||
+           mRadiusY.SharesStyleContextAllocatedObjectsWith(aOther.mRadiusY);
+  }
+
   bool IsOpaque();
   bool HasCalc();
   uint32_t Hash(PLDHashNumber aHash);
 
   NS_INLINE_DECL_REFCOUNTING(nsStyleGradient)
 
 private:
   ~nsStyleGradient() {}
@@ -186,16 +222,36 @@ enum nsStyleImageType {
  * image of type (1)).
  */
 struct nsStyleImage {
   nsStyleImage();
   ~nsStyleImage();
   nsStyleImage(const nsStyleImage& aOther);
   nsStyleImage& operator=(const nsStyleImage& aOther);
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleImage& aOther) const {
+    if (mType != aOther.mType) {
+      return false;
+    }
+    switch (mType) {
+      case eStyleImageType_Gradient:
+        return mGradient->SharesStyleContextAllocatedObjectsWith(*aOther.mGradient);
+      case eStyleImageType_Image:
+        return mCropRect &&
+               aOther.mCropRect &&
+               mCropRect->SharesStyleContextAllocatedObjectsWith(*aOther.mCropRect);
+      default:
+        NS_NOTREACHED("unexpected mType");
+      case eStyleImageType_Null:
+      case eStyleImageType_Element:
+        MOZ_ASSERT(!mCropRect);
+        return false;
+    }
+  }
+
   void SetNull();
   void SetImageData(imgIRequest* aImage);
   void TrackImage(nsPresContext* aContext);
   void UntrackImage(nsPresContext* aContext);
   void SetGradientData(nsStyleGradient* aGradient);
   void SetElementId(const char16_t* aElementId);
   void SetCropRect(nsStyleSides* aCropRect);
 
@@ -305,16 +361,17 @@ private:
   bool mImageTracked;
 #endif
 };
 
 struct nsStyleColor {
   nsStyleColor(nsPresContext* aPresContext);
   nsStyleColor(const nsStyleColor& aOther);
   ~nsStyleColor(void) {
+    // printf("~nsStyleColor %p\n", this);
     MOZ_COUNT_DTOR(nsStyleColor);
   }
 
   nsChangeHint CalcDifference(const nsStyleColor& aOther) const;
   static nsChangeHint MaxDifference() {
     return NS_STYLE_HINT_VISUAL;
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
@@ -326,16 +383,20 @@ struct nsStyleColor {
   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
     return aContext->AllocateFromShell(sz);
   }
   void Destroy(nsPresContext* aContext) {
     this->~nsStyleColor();
     aContext->FreeToShell(sizeof(nsStyleColor), this);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleColor& aOther) const {
+    return false;
+  }
+
   // Don't add ANY members to this struct!  We can achieve caching in the rule
   // tree (rather than the style tree) by letting color stay by itself! -dwh
   nscolor mColor;                 // [inherited]
 };
 
 struct nsStyleBackground {
   nsStyleBackground();
   nsStyleBackground(const nsStyleBackground& aOther);
@@ -343,24 +404,43 @@ struct nsStyleBackground {
 
   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
     return aContext->AllocateFromShell(sz);
   }
   void Destroy(nsPresContext* aContext);
 
   nsChangeHint CalcDifference(const nsStyleBackground& aOther) const;
   static nsChangeHint MaxDifference() {
-    return NS_CombineHint(nsChangeHint_UpdateEffects, NS_STYLE_HINT_VISUAL);
+    return NS_CombineHint(nsChangeHint_UpdateEffects,
+                          NS_CombineHint(NS_STYLE_HINT_VISUAL,
+                                         nsChangeHint_NeutralChange));
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference never returns nsChangeHint_NeedReflow or
     // nsChangeHint_ClearAncestorIntrinsics at all.
     return nsChangeHint(0);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleBackground& aOther) const {
+    if (mLayers.Length() != aOther.mLayers.Length()) {
+#ifdef DEBUG
+      for (uint32_t i = 0; i < std::min(mLayers.Length(), aOther.mLayers.Length()); i++) {
+        MOZ_ASSERT(!mLayers[i].SharesStyleContextAllocatedObjectsWith(aOther.mLayers[i]));
+      }
+#endif
+    } else {
+      for (uint32_t i = 0; i < mLayers.Length(); i++) {
+        if (mLayers[i].SharesStyleContextAllocatedObjectsWith(aOther.mLayers[i])) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+
   struct Position;
   friend struct Position;
   struct Position {
     typedef nsStyleCoord::Calc PositionCoord;
     PositionCoord mXPosition, mYPosition;
 
     // Initialize nothing
     Position() {}
@@ -498,16 +578,20 @@ struct nsStyleBackground {
     bool RenderingMightDependOnPositioningAreaSizeChange() const;
 
     // An equality operator that compares the images using URL-equality
     // rather than pointer-equality.
     bool operator==(const Layer& aOther) const;
     bool operator!=(const Layer& aOther) const {
       return !(*this == aOther);
     }
+
+    bool SharesStyleContextAllocatedObjectsWith(const Layer& aOther) const {
+      return mImage.SharesStyleContextAllocatedObjectsWith(aOther.mImage);
+    }
   };
 
   // The (positive) number of computed values of each property, since
   // the lengths of the lists are independent.
   uint32_t mAttachmentCount,
            mClipCount,
            mOriginCount,
            mRepeatCount,
@@ -584,16 +668,20 @@ struct nsStyleMargin {
                                           nsChangeHint_NeedDirtyReflow));
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference can return both nsChangeHint_ClearAncestorIntrinsics and
     // nsChangeHint_NeedReflow as inherited hints.
     return nsChangeHint(0);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleMargin& aOther) const {
+    return mMargin.SharesStyleContextAllocatedObjectsWith(aOther.mMargin);
+  }
+
   nsStyleSides  mMargin;          // [reset] coord, percent, calc, auto
 
   bool IsWidthDependent() const { return !mHasCachedMargin; }
   bool GetMargin(nsMargin& aMargin) const
   {
     if (mHasCachedMargin) {
       aMargin = mCachedMargin;
       return true;
@@ -624,16 +712,20 @@ struct nsStylePadding {
                            nsChangeHint_ClearDescendantIntrinsics);
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference can return nsChangeHint_ClearAncestorIntrinsics as an
     // inherited hint.
     return nsChangeHint(0);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStylePadding& aOther) const {
+    return mPadding.SharesStyleContextAllocatedObjectsWith(aOther.mPadding);
+  }
+
   nsStyleSides  mPadding;         // [reset] coord, percent, calc
 
   bool IsWidthDependent() const { return !mHasCachedPadding; }
   bool GetPadding(nsMargin& aPadding) const
   {
     if (mHasCachedPadding) {
       aPadding = mCachedPadding;
       return true;
@@ -798,25 +890,34 @@ struct nsStyleBorder {
   ~nsStyleBorder();
 
   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW;
   void Destroy(nsPresContext* aContext);
 
   nsChangeHint CalcDifference(const nsStyleBorder& aOther) const;
   static nsChangeHint MaxDifference() {
     return NS_CombineHint(NS_STYLE_HINT_REFLOW,
-                          nsChangeHint_BorderStyleNoneChange);
+                          NS_CombineHint(nsChangeHint_BorderStyleNoneChange,
+                                         nsChangeHint_NeutralChange));
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference never returns nsChangeHint_NeedReflow or
     // nsChangeHint_ClearAncestorIntrinsics as inherited hints.
     return NS_CombineHint(nsChangeHint_NeedReflow,
                           nsChangeHint_ClearAncestorIntrinsics);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleBorder& aOther) const {
+    MOZ_ASSERT(!mBorderRadius.SharesStyleContextAllocatedObjectsWith(mBorderRadius));
+    MOZ_ASSERT(!mBorderImageSlice.SharesStyleContextAllocatedObjectsWith(mBorderImageSlice));
+    MOZ_ASSERT(!mBorderImageWidth.SharesStyleContextAllocatedObjectsWith(mBorderImageWidth));
+    MOZ_ASSERT(!mBorderImageOutset.SharesStyleContextAllocatedObjectsWith(mBorderImageOutset));
+    return false;
+  }
+
   void EnsureBorderColors() {
     if (!mBorderColors) {
       mBorderColors = new nsBorderColors*[4];
       if (mBorderColors)
         for (int32_t i = 0; i < 4; i++)
           mBorderColors[i] = nullptr;
     }
   }
@@ -1028,25 +1129,31 @@ struct nsStyleOutline {
     this->~nsStyleOutline();
     aContext->FreeToShell(sizeof(nsStyleOutline), this);
   }
 
   void RecalcData(nsPresContext* aContext);
   nsChangeHint CalcDifference(const nsStyleOutline& aOther) const;
   static nsChangeHint MaxDifference() {
     return NS_CombineHint(nsChangeHint_AllReflowHints,
-                          nsChangeHint_RepaintFrame);
+                          NS_CombineHint(nsChangeHint_RepaintFrame,
+                                         nsChangeHint_NeutralChange));
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference never returns nsChangeHint_NeedReflow or
     // nsChangeHint_ClearAncestorIntrinsics as inherited hints.
     return NS_CombineHint(nsChangeHint_NeedReflow,
                           nsChangeHint_ClearAncestorIntrinsics);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleOutline& aOther) const {
+    MOZ_ASSERT(!mOutlineWidth.SharesStyleContextAllocatedObjectsWith(mOutlineWidth));
+    return mOutlineRadius.SharesStyleContextAllocatedObjectsWith(aOther.mOutlineRadius);
+  }
+
   nsStyleCorners  mOutlineRadius; // [reset] coord, percent, calc
 
   // Note that this is a specified value.  You can get the actual values
   // with GetOutlineWidth.  You cannot get the computed value directly.
   nsStyleCoord  mOutlineWidth;    // [reset] coord, enum (see nsStyleConsts.h)
   nscoord       mOutlineOffset;   // [reset]
 
   bool GetOutlineWidth(nscoord& aWidth) const
@@ -1128,16 +1235,20 @@ struct nsStyleList {
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference never returns nsChangeHint_NeedReflow or
     // nsChangeHint_ClearAncestorIntrinsics as inherited hints.
     return NS_CombineHint(nsChangeHint_NeedReflow,
                           nsChangeHint_ClearAncestorIntrinsics);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleList& aOther) const {
+    return false;
+  }
+
   imgRequestProxy* GetListStyleImage() const { return mListStyleImage; }
   void SetListStyleImage(imgRequestProxy* aReq)
   {
     if (mListStyleImage)
       mListStyleImage->UnlockImage();
     mListStyleImage = aReq;
     if (mListStyleImage)
       mListStyleImage->LockImage();
@@ -1260,16 +1371,27 @@ struct nsStylePosition {
                                        nsChangeHint_UpdateOverflow));
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference can return both nsChangeHint_ClearAncestorIntrinsics and
     // nsChangeHint_NeedReflow as inherited hints.
     return nsChangeHint(0);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStylePosition& aOther) const {
+    MOZ_ASSERT(!mZIndex.SharesStyleContextAllocatedObjectsWith(aOther.mZIndex));
+    return mOffset.SharesStyleContextAllocatedObjectsWith(aOther.mOffset) ||
+           mWidth.SharesStyleContextAllocatedObjectsWith(aOther.mWidth) ||
+           mMinWidth.SharesStyleContextAllocatedObjectsWith(aOther.mMinWidth) ||
+           mMaxWidth.SharesStyleContextAllocatedObjectsWith(aOther.mMaxWidth) ||
+           mHeight.SharesStyleContextAllocatedObjectsWith(aOther.mHeight) ||
+           mMinHeight.SharesStyleContextAllocatedObjectsWith(aOther.mMinHeight) ||
+           mFlexBasis.SharesStyleContextAllocatedObjectsWith(aOther.mFlexBasis);
+  }
+
   nsStyleSides  mOffset;                // [reset] coord, percent, calc, auto
   nsStyleCoord  mWidth;                 // [reset] coord, percent, enum, calc, auto
   nsStyleCoord  mMinWidth;              // [reset] coord, percent, enum, calc
   nsStyleCoord  mMaxWidth;              // [reset] coord, percent, enum, calc, none
   nsStyleCoord  mHeight;                // [reset] coord, percent, calc, auto
   nsStyleCoord  mMinHeight;             // [reset] coord, percent, calc
   nsStyleCoord  mMaxHeight;             // [reset] coord, percent, calc, none
   nsStyleCoord  mFlexBasis;             // [reset] coord, percent, enum, calc, auto
@@ -1452,16 +1574,20 @@ struct nsStyleTextReset {
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference never returns nsChangeHint_NeedReflow or
     // nsChangeHint_ClearAncestorIntrinsics as inherited hints.
     return NS_CombineHint(nsChangeHint_NeedReflow,
                           nsChangeHint_ClearAncestorIntrinsics);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleTextReset& aOther) const {
+    return mVerticalAlign.SharesStyleContextAllocatedObjectsWith(aOther.mVerticalAlign);
+  }
+
   nsStyleCoord  mVerticalAlign;         // [reset] coord, percent, calc, enum (see nsStyleConsts.h)
   nsStyleTextOverflow mTextOverflow;    // [reset] enum, string
 
   uint8_t mTextDecorationLine;          // [reset] see nsStyleConsts.h
   uint8_t mUnicodeBidi;                 // [reset] see nsStyleConsts.h
 protected:
   uint8_t mTextDecorationStyle;         // [reset] see nsStyleConsts.h
 
@@ -1487,16 +1613,22 @@ struct nsStyleText {
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference never returns nsChangeHint_NeedReflow or
     // nsChangeHint_ClearAncestorIntrinsics as inherited hints.
     return NS_CombineHint(nsChangeHint_NeedReflow,
                           nsChangeHint_ClearAncestorIntrinsics);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleText& aOther) const {
+    MOZ_ASSERT(!mLetterSpacing.SharesStyleContextAllocatedObjectsWith(mLetterSpacing));
+    MOZ_ASSERT(!mLineHeight.SharesStyleContextAllocatedObjectsWith(mLineHeight));
+    return mTextIndent.SharesStyleContextAllocatedObjectsWith(aOther.mTextIndent);
+  }
+
   uint8_t mTextAlign;                   // [inherited] see nsStyleConsts.h
   uint8_t mTextAlignLast;               // [inherited] see nsStyleConsts.h
   bool mTextAlignTrue : 1;              // [inherited] see nsStyleConsts.h
   bool mTextAlignLastTrue : 1;          // [inherited] see nsStyleConsts.h
   uint8_t mTextTransform;               // [inherited] see nsStyleConsts.h
   uint8_t mWhiteSpace;                  // [inherited] see nsStyleConsts.h
   uint8_t mWordBreak;                   // [inherited] see nsStyleConsts.h
   uint8_t mWordWrap;                    // [inherited] see nsStyleConsts.h
@@ -1669,16 +1801,20 @@ struct nsStyleVisibility {
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference never returns nsChangeHint_NeedReflow or
     // nsChangeHint_ClearAncestorIntrinsics as inherited hints.
     return NS_CombineHint(nsChangeHint_NeedReflow,
                           nsChangeHint_ClearAncestorIntrinsics);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleVisibility& aOther) const {
+    return false;
+  }
+
   nsStyleImageOrientation mImageOrientation;  // [inherited]
   uint8_t mDirection;                  // [inherited] see nsStyleConsts.h NS_STYLE_DIRECTION_*
   uint8_t mVisible;                    // [inherited]
   uint8_t mPointerEvents;              // [inherited] see nsStyleConsts.h
   uint8_t mWritingMode;                // [inherited] see nsStyleConsts.h
 
   bool IsVisible() const {
     return (mVisible == NS_STYLE_VISIBILITY_VISIBLE);
@@ -1801,16 +1937,20 @@ struct nsTransition {
   void CopyPropertyFrom(const nsTransition& aOther)
     {
       mProperty = aOther.mProperty;
       mUnknownProperty = aOther.mUnknownProperty;
     }
 
   nsTimingFunction& TimingFunctionSlot() { return mTimingFunction; }
 
+  bool operator==(const nsTransition& aOther) const;
+  bool operator!=(const nsTransition& aOther) const
+    { return !(*this == aOther); }
+
 private:
   nsTimingFunction mTimingFunction;
   float mDuration;
   float mDelay;
   nsCSSProperty mProperty;
   nsCOMPtr<nsIAtom> mUnknownProperty; // used when mProperty is
                                       // eCSSProperty_UNKNOWN
 };
@@ -1840,16 +1980,20 @@ struct nsAnimation {
   void SetDirection(uint8_t aDirection) { mDirection = aDirection; }
   void SetFillMode(uint8_t aFillMode) { mFillMode = aFillMode; }
   void SetPlayState(uint8_t aPlayState) { mPlayState = aPlayState; }
   void SetIterationCount(float aIterationCount)
     { mIterationCount = aIterationCount; }
 
   nsTimingFunction& TimingFunctionSlot() { return mTimingFunction; }
 
+  bool operator==(const nsAnimation& aOther) const;
+  bool operator!=(const nsAnimation& aOther) const
+    { return !(*this == aOther); }
+
 private:
   nsTimingFunction mTimingFunction;
   float mDuration;
   float mDelay;
   nsString mName; // empty string for 'none'
   uint8_t mDirection;
   uint8_t mFillMode;
   uint8_t mPlayState;
@@ -1873,24 +2017,34 @@ struct nsStyleDisplay {
 
   nsChangeHint CalcDifference(const nsStyleDisplay& aOther) const;
   static nsChangeHint MaxDifference() {
     // All the parts of FRAMECHANGE are present in CalcDifference.
     return nsChangeHint(NS_STYLE_HINT_FRAMECHANGE |
                         nsChangeHint_UpdateOpacityLayer |
                         nsChangeHint_UpdateTransformLayer |
                         nsChangeHint_UpdateOverflow |
-                        nsChangeHint_AddOrRemoveTransform);
+                        nsChangeHint_AddOrRemoveTransform |
+                        nsChangeHint_NeutralChange);
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference can return both nsChangeHint_ClearAncestorIntrinsics and
     // nsChangeHint_NeedReflow as inherited hints.
     return nsChangeHint(0);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleDisplay& aOther) const {
+    MOZ_ASSERT(!mChildPerspective.SharesStyleContextAllocatedObjectsWith(mChildPerspective));
+    return mTransformOrigin[0].SharesStyleContextAllocatedObjectsWith(aOther.mTransformOrigin[0]) ||
+           mTransformOrigin[1].SharesStyleContextAllocatedObjectsWith(aOther.mTransformOrigin[1]) ||
+           mTransformOrigin[2].SharesStyleContextAllocatedObjectsWith(aOther.mTransformOrigin[2]) ||
+           mPerspectiveOrigin[0].SharesStyleContextAllocatedObjectsWith(aOther.mPerspectiveOrigin[0]) ||
+           mPerspectiveOrigin[1].SharesStyleContextAllocatedObjectsWith(aOther.mPerspectiveOrigin[1]);
+  }
+
   // We guarantee that if mBinding is non-null, so are mBinding->GetURI() and
   // mBinding->mOriginPrincipal.
   nsRefPtr<mozilla::css::URLValue> mBinding;    // [reset]
   nsRect  mClip;                // [reset] offsets from upper-left border edge
   float   mOpacity;             // [reset]
   uint8_t mDisplay;             // [reset] see nsStyleConsts.h NS_STYLE_DISPLAY_*
   uint8_t mOriginalDisplay;     // [reset] saved mDisplay for position:absolute/fixed
                                 //         and float:left/right; otherwise equal
@@ -2072,16 +2226,20 @@ struct nsStyleTable {
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference never returns nsChangeHint_NeedReflow or
     // nsChangeHint_ClearAncestorIntrinsics as inherited hints.
     return NS_CombineHint(nsChangeHint_NeedReflow,
                           nsChangeHint_ClearAncestorIntrinsics);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleTable& aOther) const {
+    return false;
+  }
+
   uint8_t       mLayoutStrategy;// [reset] see nsStyleConsts.h NS_STYLE_TABLE_LAYOUT_*
   uint8_t       mFrame;         // [reset] see nsStyleConsts.h NS_STYLE_TABLE_FRAME_*
   uint8_t       mRules;         // [reset] see nsStyleConsts.h NS_STYLE_TABLE_RULES_*
   int32_t       mSpan;          // [reset] the number of columns spanned by a colgroup or col
 };
 
 struct nsStyleTableBorder {
   nsStyleTableBorder(nsPresContext* aContext);
@@ -2102,16 +2260,20 @@ struct nsStyleTableBorder {
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference never returns nsChangeHint_NeedReflow or
     // nsChangeHint_ClearAncestorIntrinsics as inherited hints.
     return NS_CombineHint(nsChangeHint_NeedReflow,
                           nsChangeHint_ClearAncestorIntrinsics);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleTableBorder& aOther) const {
+    return false;
+  }
+
   nscoord       mBorderSpacingX;// [inherited]
   nscoord       mBorderSpacingY;// [inherited]
   uint8_t       mBorderCollapse;// [inherited]
   uint8_t       mCaptionSide;   // [inherited]
   uint8_t       mEmptyCells;    // [inherited]
 };
 
 enum nsStyleContentType {
@@ -2184,16 +2346,20 @@ struct nsStyleQuotes {
   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
     return aContext->AllocateFromShell(sz);
   }
   void Destroy(nsPresContext* aContext) {
     this->~nsStyleQuotes();
     aContext->FreeToShell(sizeof(nsStyleQuotes), this);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleQuotes& aOther) const {
+    return false;
+  }
+
   void SetInitial();
   void CopyFrom(const nsStyleQuotes& aSource);
 
   nsChangeHint CalcDifference(const nsStyleQuotes& aOther) const;
   static nsChangeHint MaxDifference() {
     return NS_STYLE_HINT_FRAMECHANGE;
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
@@ -2271,16 +2437,20 @@ struct nsStyleContent {
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference never returns nsChangeHint_NeedReflow or
     // nsChangeHint_ClearAncestorIntrinsics as inherited hints.
     return NS_CombineHint(nsChangeHint_NeedReflow,
                           nsChangeHint_ClearAncestorIntrinsics);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleContent& aOther) const {
+    return false;
+  }
+
   uint32_t  ContentCount(void) const  { return mContentCount; } // [reset]
 
   const nsStyleContentData& ContentAt(uint32_t aIndex) const {
     NS_ASSERTION(aIndex < mContentCount, "out of range");
     return mContents[aIndex];
   }
 
   nsStyleContentData& ContentAt(uint32_t aIndex) {
@@ -2381,16 +2551,20 @@ struct nsStyleUIReset {
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference never returns nsChangeHint_NeedReflow or
     // nsChangeHint_ClearAncestorIntrinsics as inherited hints.
     return NS_CombineHint(nsChangeHint_NeedReflow,
                           nsChangeHint_ClearAncestorIntrinsics);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleUIReset& aOther) const {
+    return false;
+  }
+
   uint8_t   mUserSelect;      // [reset] (selection-style)
   uint8_t   mForceBrokenImageIcon; // [reset]  (0 if not forcing, otherwise forcing)
   uint8_t   mIMEMode;         // [reset]
   uint8_t   mWindowShadow;    // [reset]
 };
 
 struct nsCursorImage {
   bool mHaveHotspot;
@@ -2431,25 +2605,31 @@ struct nsStyleUserInterface {
   }
   void Destroy(nsPresContext* aContext) {
     this->~nsStyleUserInterface();
     aContext->FreeToShell(sizeof(nsStyleUserInterface), this);
   }
 
   nsChangeHint CalcDifference(const nsStyleUserInterface& aOther) const;
   static nsChangeHint MaxDifference() {
-    return nsChangeHint(nsChangeHint_UpdateCursor | NS_STYLE_HINT_FRAMECHANGE);
+    return NS_CombineHint(NS_STYLE_HINT_FRAMECHANGE,
+                          NS_CombineHint(nsChangeHint_UpdateCursor,
+                                         nsChangeHint_InheritedNeutralChange));
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference never returns nsChangeHint_NeedReflow or
     // nsChangeHint_ClearAncestorIntrinsics as inherited hints.
     return NS_CombineHint(nsChangeHint_NeedReflow,
                           nsChangeHint_ClearAncestorIntrinsics);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleUserInterface& aOther) const {
+    return false;
+  }
+
   uint8_t   mUserInput;       // [inherited]
   uint8_t   mUserModify;      // [inherited] (modify-content)
   uint8_t   mUserFocus;       // [inherited] (auto-select)
 
   uint8_t   mCursor;          // [inherited] See nsStyleConsts.h
 
   uint32_t mCursorArrayLength;
   nsCursorImage *mCursorArray;// [inherited] The specified URL values
@@ -2481,16 +2661,20 @@ struct nsStyleXUL {
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference never returns nsChangeHint_NeedReflow or
     // nsChangeHint_ClearAncestorIntrinsics as inherited hints.
     return NS_CombineHint(nsChangeHint_NeedReflow,
                           nsChangeHint_ClearAncestorIntrinsics);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleXUL& aOther) const {
+    return false;
+  }
+
   float         mBoxFlex;               // [reset] see nsStyleConsts.h
   uint32_t      mBoxOrdinal;            // [reset] see nsStyleConsts.h
   uint8_t       mBoxAlign;              // [reset] see nsStyleConsts.h
   uint8_t       mBoxDirection;          // [reset] see nsStyleConsts.h
   uint8_t       mBoxOrient;             // [reset] see nsStyleConsts.h
   uint8_t       mBoxPack;               // [reset] see nsStyleConsts.h
   bool          mStretchStack;          // [reset] see nsStyleConsts.h
 };
@@ -2505,25 +2689,32 @@ struct nsStyleColumn {
   }
   void Destroy(nsPresContext* aContext) {
     this->~nsStyleColumn();
     aContext->FreeToShell(sizeof(nsStyleColumn), this);
   }
 
   nsChangeHint CalcDifference(const nsStyleColumn& aOther) const;
   static nsChangeHint MaxDifference() {
-    return NS_STYLE_HINT_FRAMECHANGE;
+    return NS_CombineHint(NS_STYLE_HINT_FRAMECHANGE,
+                          nsChangeHint_NeutralChange);
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference never returns nsChangeHint_NeedReflow or
     // nsChangeHint_ClearAncestorIntrinsics as inherited hints.
     return NS_CombineHint(nsChangeHint_NeedReflow,
                           nsChangeHint_ClearAncestorIntrinsics);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleColumn& aOther) const {
+    MOZ_ASSERT(!mColumnWidth.SharesStyleContextAllocatedObjectsWith(mColumnWidth));
+    MOZ_ASSERT(!mColumnGap.SharesStyleContextAllocatedObjectsWith(mColumnGap));
+    return false;
+  }
+
   /**
    * This is the maximum number of columns we can process. It's used in both
    * nsColumnSetFrame and nsRuleNode.
    */
   static const uint32_t kMaxColumnCount;
 
   uint32_t     mColumnCount; // [reset] see nsStyleConsts.h
   nsStyleCoord mColumnWidth; // [reset] coord, auto
@@ -2604,16 +2795,27 @@ struct nsStyleSVG {
                                          nsChangeHint_RepaintFrame);
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference never returns nsChangeHint_NeedReflow as an inherited hint
     // and never returns nsChangeHint_ClearAncestorIntrinsics at all.
     return nsChangeHint_NeedReflow;
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleSVG& aOther) const {
+#ifdef DEBUG
+    for (uint32_t i = 0; i < mStrokeDasharrayLength; i++) {
+      MOZ_ASSERT(!mStrokeDasharray[i].SharesStyleContextAllocatedObjectsWith(mStrokeDasharray[i]));
+    }
+#endif
+    MOZ_ASSERT(!mStrokeDashoffset.SharesStyleContextAllocatedObjectsWith(mStrokeDashoffset));
+    MOZ_ASSERT(!mStrokeWidth.SharesStyleContextAllocatedObjectsWith(mStrokeWidth));
+    return false;
+  }
+
   nsStyleSVGPaint  mFill;             // [inherited]
   nsStyleSVGPaint  mStroke;           // [inherited]
   nsCOMPtr<nsIURI> mMarkerEnd;        // [inherited]
   nsCOMPtr<nsIURI> mMarkerMid;        // [inherited]
   nsCOMPtr<nsIURI> mMarkerStart;      // [inherited]
   nsStyleCoord    *mStrokeDasharray;  // [inherited] coord, percent, factor
 
   nsStyleCoord     mStrokeDashoffset; // [inherited] coord, percent, factor
@@ -2672,24 +2874,34 @@ struct nsStyleFilter {
   nsStyleFilter();
   nsStyleFilter(const nsStyleFilter& aSource);
   ~nsStyleFilter();
 
   nsStyleFilter& operator=(const nsStyleFilter& aOther);
 
   bool operator==(const nsStyleFilter& aOther) const;
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleFilter& aOther) const {
+    MOZ_ASSERT(!HasFilterParameter() ||
+               !GetFilterParameter().SharesStyleContextAllocatedObjectsWith(GetFilterParameter()));
+    return false;
+  }
+
   int32_t GetType() const {
     return mType;
   }
 
+  bool HasFilterParameter() const {
+    return mType != NS_STYLE_FILTER_DROP_SHADOW &&
+           mType != NS_STYLE_FILTER_URL &&
+           mType != NS_STYLE_FILTER_NONE;
+  }
+
   const nsStyleCoord& GetFilterParameter() const {
-    NS_ASSERTION(mType != NS_STYLE_FILTER_DROP_SHADOW &&
-                 mType != NS_STYLE_FILTER_URL &&
-                 mType != NS_STYLE_FILTER_NONE, "wrong filter type");
+    NS_ASSERTION(HasFilterParameter(), "wrong filter type");
     return mFilterParameter;
   }
   void SetFilterParameter(const nsStyleCoord& aFilterParameter,
                           int32_t aType);
 
   nsIURI* GetURL() const {
     NS_ASSERTION(mType == NS_STYLE_FILTER_URL, "wrong filter type");
     return mURL;
@@ -2742,16 +2954,25 @@ struct nsStyleSVGReset {
     return NS_CombineHint(nsChangeHint_NeedReflow,
                           nsChangeHint_ClearAncestorIntrinsics);
   }
 
   bool HasFilters() const {
     return mFilters.Length() > 0;
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleSVGReset& aOther) const {
+#ifdef DEBUG
+    for (uint32_t i = 0; i < mFilters.Length(); i++) {
+      MOZ_ASSERT(!mFilters[i].SharesStyleContextAllocatedObjectsWith(mFilters[i]));
+    }
+#endif
+    return false;
+  }
+
   nsCOMPtr<nsIURI> mClipPath;         // [reset]
   nsTArray<nsStyleFilter> mFilters;   // [reset]
   nsCOMPtr<nsIURI> mMask;             // [reset]
   nscolor          mStopColor;        // [reset]
   nscolor          mFloodColor;       // [reset]
   nscolor          mLightingColor;    // [reset]
 
   float            mStopOpacity;      // [reset]
@@ -2780,12 +3001,16 @@ struct nsStyleVariables {
     return nsChangeHint(0);
   }
   static nsChangeHint MaxDifferenceNeverInherited() {
     // CalcDifference never returns nsChangeHint_NeedReflow or
     // nsChangeHint_ClearAncestorIntrinsics at all.
     return nsChangeHint(0);
   }
 
+  bool SharesStyleContextAllocatedObjectsWith(const nsStyleVariables& aOther) const {
+    return false;
+  }
+
   mozilla::CSSVariableValues mVariables;
 };
 
 #endif /* nsStyleStruct_h___ */
diff --git a/layout/svg/crashtests/crashtests.list b/layout/svg/crashtests/crashtests.list
--- a/layout/svg/crashtests/crashtests.list
+++ b/layout/svg/crashtests/crashtests.list
@@ -56,17 +56,17 @@ load 384637-1.svg
 load 384728-1.svg
 load 385246-1.svg
 load 385246-2.svg
 load 385552-1.svg
 load 385552-2.svg
 load 385840-1.svg
 load 385852-1.svg
 load 386475-1.xhtml
-asserts(1) load 386566-1.svg # Bug 713626
+asserts(0) load 386566-1.svg # Bug 713626
 load 386690-1.svg
 load 387290-1.svg
 load 402408-1.svg
 load 404677-1.xhtml
 load 409565-1.xhtml
 load 409573-1.svg
 load 420697-1.svg
 load 420697-2.svg
