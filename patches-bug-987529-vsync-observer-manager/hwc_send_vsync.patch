# HG changeset patch
# User vlin <vlin@mozilla.com>
# Date 1398068233 -28800
# Node ID 10e81e1b2f6204a53ffc3da21934ceaa93d59338
# Parent 8cfe066598863db89f615918dd3f50f7d9a61832
Bug 987527: Register Vsync monitor to HWComposer and notify to gecko/hal r=mwu

diff --git a/b2g/app/b2g.js b/b2g/app/b2g.js
--- a/b2g/app/b2g.js
+++ b/b2g/app/b2g.js
@@ -286,21 +286,23 @@ pref("ui.dragThresholdX", 25);
 pref("ui.dragThresholdY", 25);
 
 // Layers Acceleration.  We can only have nice things on gonk, because
 // they're not maintained anywhere else.
 pref("layers.offmainthreadcomposition.enabled", true);
 pref("layers.offmainthreadcomposition.async-animations", true);
 #ifndef MOZ_WIDGET_GONK
 pref("dom.ipc.tabs.disabled", true);
+pref("hal.hw-vsync", false);
 #else
 pref("dom.ipc.tabs.disabled", false);
 pref("layers.acceleration.disabled", false);
 pref("layers.async-pan-zoom.enabled", true);
 pref("gfx.content.azure.backends", "cairo");
+pref("hal.hw-vsync", true);
 #endif
 
 // Web Notifications
 pref("notification.feature.enabled", true);
 
 // IndexedDB
 pref("dom.indexedDB.warningQuota", 5);
 
diff --git a/widget/gonk/HwcComposer2D.cpp b/widget/gonk/HwcComposer2D.cpp
--- a/widget/gonk/HwcComposer2D.cpp
+++ b/widget/gonk/HwcComposer2D.cpp
@@ -27,16 +27,18 @@
 #include "mozilla/layers/ShadowLayerUtilsGralloc.h"
 #include "mozilla/layers/TextureHostOGL.h"  // for TextureHostOGL
 #include "mozilla/StaticPtr.h"
 #include "cutils/properties.h"
 #include "gfx2DGlue.h"
 
 #if ANDROID_VERSION >= 17
 #include "libdisplay/FramebufferSurface.h"
+#include "GeckoProfiler.h"
+#include "nsThreadUtils.h"
 #ifndef HWC_BLIT
 #define HWC_BLIT (HWC_FRAMEBUFFER_TARGET + 1)
 #endif
 #endif
 
 #ifdef LOG_TAG
 #undef LOG_TAG
 #endif
@@ -61,32 +63,51 @@
 
 using namespace android;
 using namespace mozilla::layers;
 
 namespace mozilla {
 
 static StaticRefPtr<HwcComposer2D> sInstance;
 
+#if ANDROID_VERSION >= 17
+struct HwcComposer2D::cb_context {
+    struct callbacks : public hwc_procs_t {
+        // these are here to facilitate the transition when adding
+        // new callbacks (an implementation can check for NULL before
+        // calling a new callback).
+        void (*zero[4])(void);
+    };
+    callbacks procs;
+    HwcComposer2D* hwc;
+};
+#endif
+
 HwcComposer2D::HwcComposer2D()
     : mHwc(nullptr)
     , mList(nullptr)
     , mMaxLayerCount(0)
     , mColorFill(false)
     , mRBSwapSupport(false)
 #if ANDROID_VERSION >= 17
     , mPrevRetireFence(Fence::NO_FENCE)
     , mPrevDisplayFence(Fence::NO_FENCE)
+    , mVSyncCount(0)
+    , mVsyncData(0, 0)
+    , mCBContext(new cb_context)
 #endif
     , mPrepared(false)
 {
 }
 
 HwcComposer2D::~HwcComposer2D() {
     free(mList);
+#if ANDROID_VERSION >= 17
+    delete mCBContext;	
+#endif
 }
 
 int
 HwcComposer2D::Init(hwc_display_t dpy, hwc_surface_t sur)
 {
     MOZ_ASSERT(!Initialized());
 
     mHwc = (HwcDevice*)GetGonkDisplay()->GetHWCDevice();
@@ -109,16 +130,28 @@ HwcComposer2D::Init(hwc_display_t dpy, h
         }
         if (mHwc->query(mHwc, HwcUtils::HWC_FORMAT_RB_SWAP, &supported) == NO_ERROR) {
             mRBSwapSupport = !!supported;
         }
     } else {
         mColorFill = false;
         mRBSwapSupport = false;
     }
+
+    if (mHwc->registerProcs) {
+        mCBContext->hwc = this;
+	 mCBContext->procs.invalidate = &hook_invalidate;
+	 mCBContext->procs.vsync = &hook_vsync;
+        mCBContext->procs.hotplug = &hook_hotplug;
+	 memset(mCBContext->procs.zero, 0, sizeof(mCBContext->procs.zero));
+	 mHwc->registerProcs(mHwc, &mCBContext->procs);
+    }
+
+    mHwc->eventControl(mHwc, HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, 1);
+
 #else
     char propValue[PROPERTY_VALUE_MAX];
     property_get("ro.display.colorfill", propValue, "0");
     mColorFill = (atoi(propValue) == 1) ? true : false;
     mRBSwapSupport = true;
 #endif
 
     mDpy = dpy;
@@ -132,16 +165,73 @@ HwcComposer2D::GetInstance()
 {
     if (!sInstance) {
         LOGI("Creating new instance");
         sInstance = new HwcComposer2D();
     }
     return sInstance;
 }
 
+#if ANDROID_VERSION >= 17
+void
+HwcComposer2D::hook_invalidate(const struct hwc_procs* procs)
+{
+    cb_context* ctx = reinterpret_cast<cb_context*>(
+            const_cast<hwc_procs_t*>(procs));
+    ctx->hwc->invalidate();
+}
+
+void
+HwcComposer2D::hook_vsync(const struct hwc_procs* procs, int disp,
+        int64_t timestamp)
+{
+
+
+    cb_context* ctx = reinterpret_cast<cb_context*>(
+            const_cast<hwc_procs_t*>(procs));
+    ctx->hwc->vsync(disp, timestamp);
+}
+
+void
+HwcComposer2D::hook_hotplug(const struct hwc_procs* procs, int disp,
+        int connected)
+{
+    cb_context* ctx = reinterpret_cast<cb_context*>(
+            const_cast<hwc_procs_t*>(procs));
+    ctx->hwc->hotplug(disp, connected);
+}
+
+void
+HwcComposer2D::invalidate()
+{
+    // N/A
+}
+
+void
+HwcComposer2D::vsync(int disp, int64_t timestamp)
+{
+    char propValue[PROPERTY_VALUE_MAX];
+    property_get("debug.vsync_div", propValue, "1");
+    int div = atoi(propValue);
+
+    if (!(mVSyncCount%div)) {
+        mVsyncData.timeStamp() = base::TimeTicks::HighResNow().ToInternalValue();
+        //mVsyncData.timeStamp() = timestamp;
+        ++(mVsyncData.frameNumber());
+        VsyncDispatcher::GetInstance()->NotifyVsync(mVsyncData);
+    }
+}
+
+void
+HwcComposer2D::hotplug(int disp, int connected)
+{
+    // N/A
+}
+#endif
+
 bool
 HwcComposer2D::ReallocLayerList()
 {
     int size = sizeof(HwcList) +
         ((mMaxLayerCount + LAYER_COUNT_INCREMENTS) * sizeof(HwcLayer));
 
     HwcList* listrealloc = (HwcList*)realloc(mList, size);
 
diff --git a/widget/gonk/HwcComposer2D.h b/widget/gonk/HwcComposer2D.h
--- a/widget/gonk/HwcComposer2D.h
+++ b/widget/gonk/HwcComposer2D.h
@@ -22,16 +22,18 @@
 #include <vector>
 #include <list>
 
 #include <hardware/hwcomposer.h>
 #if ANDROID_VERSION >= 17
 #include <ui/Fence.h>
 #endif
 
+#include "VsyncDispatcher.h"
+
 namespace mozilla {
 
 namespace layers {
 class ContainerLayer;
 class Layer;
 }
 
 //Holds a dynamically allocated vector of rectangles
@@ -69,16 +71,26 @@ public:
     HwcComposer2D();
     virtual ~HwcComposer2D();
 
     int Init(hwc_display_t aDisplay, hwc_surface_t aSurface);
 
     bool Initialized() const { return mHwc; }
 
     static HwcComposer2D* GetInstance();
+#if ANDROID_VERSION >= 17
+    static void hook_invalidate(const struct hwc_procs* procs);
+    static void hook_vsync(const struct hwc_procs* procs, int disp,
+                           int64_t timestamp);
+    static void hook_hotplug(const struct hwc_procs* procs, int disp,
+                             int connected);
+    inline void invalidate();
+    inline void vsync(int disp, int64_t timestamp);
+    inline void hotplug(int disp, int connected);
+#endif
 
     // Returns TRUE if the container has been succesfully rendered
     // Returns FALSE if the container cannot be fully rendered
     // by this composer so nothing was rendered at all
     bool TryRender(layers::Layer* aRoot, const gfx::Matrix& aGLWorldTransform,
                    bool aGeometryChanged) MOZ_OVERRIDE;
 
     bool Render(EGLDisplay dpy, EGLSurface sur);
@@ -103,16 +115,21 @@ private:
     bool                    mColorFill;
     bool                    mRBSwapSupport;
     //Holds all the dynamically allocated RectVectors needed
     //to render the current frame
     std::list<RectVector>   mVisibleRegions;
 #if ANDROID_VERSION >= 17
     android::sp<android::Fence> mPrevRetireFence;
     android::sp<android::Fence> mPrevDisplayFence;
+    struct cb_context;
+    cb_context*                     mCBContext;
+    size_t                          mVSyncCount;
+
+    mozilla::layers::VsyncData      mVsyncData;
 #endif
     nsTArray<layers::LayerComposite*> mHwcLayerMap;
     bool                    mPrepared;
 };
 
 } // namespace mozilla
 
 #endif // mozilla_HwcComposer2D
diff --git a/widget/gonk/libdisplay/GonkDisplayJB.cpp b/widget/gonk/libdisplay/GonkDisplayJB.cpp
--- a/widget/gonk/libdisplay/GonkDisplayJB.cpp
+++ b/widget/gonk/libdisplay/GonkDisplayJB.cpp
@@ -152,34 +152,49 @@ ANativeWindow*
 GonkDisplayJB::GetNativeWindow()
 {
     return mSTClient.get();
 }
 
 void
 GonkDisplayJB::SetEnabled(bool enabled)
 {
-    if (enabled) {
-        autosuspend_disable();
-        mPowerModule->setInteractive(mPowerModule, true);
+    static bool sState;
+
+     if (enabled) {
+         autosuspend_disable();
+         mPowerModule->setInteractive(mPowerModule, true);
+     }
+
+    if (mHwc) {
+        if (sState != enabled)	 {
+	     if (enabled) {
+                mHwc->blank(mHwc, HWC_DISPLAY_PRIMARY, false);
+	         mHwc->eventControl(mHwc, HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, true);
+	     }
+	     else {
+	         mHwc->eventControl(mHwc, HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, false);
+                mHwc->blank(mHwc, HWC_DISPLAY_PRIMARY, true);
+	     }
+        }
     }
-
-    if (mHwc)
-        mHwc->blank(mHwc, HWC_DISPLAY_PRIMARY, !enabled);
     else if (mFBDevice->enableScreen)
         mFBDevice->enableScreen(mFBDevice, enabled);
 
     if (mEnabledCallback)
         mEnabledCallback(enabled);
 
     if (!enabled) {
         autosuspend_enable();
         mPowerModule->setInteractive(mPowerModule, false);
     }
-}
+
+    sState = enabled;
+
+ }
 
 void
 GonkDisplayJB::OnEnabled(OnEnabledCallbackType callback)
 {
     mEnabledCallback = callback;
 }
 
 void*
